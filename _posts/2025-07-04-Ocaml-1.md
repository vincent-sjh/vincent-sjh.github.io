---
title: Ocaml(1) | Vincent's Technical Reports (Vol. 2)
date: 2025-07-04 00:30:00 +0800
categories: [Vincent's technical reports]
tags: [Ocaml]
pin: true
author: 宋建昊

toc: true
comments: true
typora-root-url: ../../framontom.github.io
math: false
mermaid: true
---
# Ocaml编程语言初探


```shell
sudo apt install ocaml
sudo apt install utop
```
`UTop` 是`Ocaml`的`REPL`(`read evaluate print loop`)，在`Ocaml`中也叫做`toplevel`。


- 输入表达式，可以看到对应的带有类型的输出，需要记得在每行后结尾加两个分号`;;`。
- 关闭`UTop`可以使用快捷键`ctrl+d`或者在`UTop`中执行`exit 0;;`。

```Ocaml
─( 20:01:07 )─< command 0 >───────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────{ counter: 0 }─
utop # 1 + 2;;
- : int = 3
─( 20:01:07 )─< command 1 >───────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────{ counter: 0 }─
utop # exit 0;;
```

- 可以使用`let`定义变量，但Ocaml中的变量值是不可变的。
- `=`相当于C语言中的双等号`==`，代表判定等号两侧是否相等。
- 变量名必须以小写字母或者下划线开头。

```Ocaml
─( 20:01:58 )─< command 0 >───────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────{ counter: 0 }─
utop # let x = 50;;
val x : int = 50
─( 20:01:58 )─< command 1 >───────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────{ counter: 0 }─
utop # x = 50;;
- : bool = true
─( 20:03:28 )─< command 2 >───────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────{ counter: 0 }─
utop # x = 500;;
- : bool = false
```

- 可以使用`let`+`in`的语法来计算函数值。
```Ocaml
─( 20:03:54 )─< command 3 >───────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────{ counter: 0 }─
utop # let x = 100 in x * (x - 1);;
- : int = 9900
─( 20:15:07 )─< command 4 >───────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────{ counter: 0 }─
utop # let x = 10 in let y = 100 in x * y;;
- : int = 1000
```
- `let`也可以用来定义一元函数甚至多元函数。
```Ocaml
─( 20:17:51 )─< command 5 >───────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────{ counter: 0 }─
utop # let square x = x * x;;
val square : int -> int = <fun>
─( 20:17:53 )─< command 6 >───────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────{ counter: 0 }─
utop # let area = square 100;;
val area : int = 10000
─( 20:18:18 )─< command 7 >───────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────{ counter: 0 }─
utop # let multiply x y = x * y;;
val multiply : int -> int -> int = <fun>
```

- 可以使用`let rec`来定义递归函数。
```Ocaml
─( 20:18:33 )─< command 8 >───────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────{ counter: 0 }─
utop # let rec range a b = if a > b then [] else a :: range (a + 1) b;;
val range : int -> int -> int list = <fun>
─( 20:20:21 )─< command 9 >───────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────{ counter: 0 }─
utop # let digits = range 0 9;;
val digits : int list = [0; 1; 2; 3; 4; 5; 6; 7; 8; 9]
```

- `Ocaml`是强静态类型语言，运行前编译器会自动进行类型推断，基本类型和其他语言类似。
- `Ocaml`中禁止隐式的类型转换。
```Ocaml
─( 20:23:53 )─< command 10 >──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────{ counter: 0 }─
utop # 1 + 1;;
- : int = 2
─( 20:25:08 )─< command 11 >──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────{ counter: 0 }─
utop # 1.0 +. 1.0;;
- : float = 2.
─( 20:25:17 )─< command 12 >──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────{ counter: 0 }─
utop # false;;
- : bool = false
─( 20:25:47 )─< command 13 >──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────{ counter: 0 }─
utop # 's';;
- : char = 's'
─( 20:26:22 )─< command 14 >──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────{ counter: 0 }─
utop # "Vincent";;
- : string = "Vincent"
```

- 可以使用模式匹配方便地处理各种情况，非常适合`corner case`很多的情况。
```Ocaml
─( 20:27:51 )─< command 15 >──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────{ counter: 0 }─
utop #  let rec factorial n =
match n with
| 0 | 1 -> 1
| _ -> n * factorial (n - 1);;
val factorial : int -> int = <fun>
─( 20:51:20 )─< command 16 >──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────{ counter: 0 }─
utop # factorial 5;;
- : int = 120
```

- 列表`list`
```Ocaml
─( 20:52:55 )─< command 17 >──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────{ counter: 0 }─
utop # [];;
- : 'a list = []
─( 20:53:12 )─< command 18 >──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────{ counter: 0 }─
utop # [1;1];;
- : int list = [1; 1]
─( 20:55:47 )─< command 19 >──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────{ counter: 0 }─
utop # [true;false];;
- : bool list = [true; false]
─( 20:55:47 )─< command 20 >──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────{ counter: 0 }─
utop # [[1;2];[1;2]];;
- : int list list = [[1;2];[1;2]]
```
- 操作符有`::`(用来在列表前添加一个元素)和`@`(用来连接两个列表)。
- `List`的方法`hd`和`tl`可以分别获得列表头尾的元素。
```Ocaml
─( 20:56:02 )─< command 21 >──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────{ counter: 0 }─
utop # 1 :: [2;3];;
- : int list = [1; 2; 3]
─( 20:56:43 )─< command 22 >──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────{ counter: 0 }─
utop # [1] @ [2;3];;
- : int list = [1; 2; 3]
─( 21:00:45 )─< command 23 >──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────{ counter: 0 }─
utop # List.hd [1;2;3;4];;
- : int = 1
─( 21:00:59 )─< command 24 >──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────{ counter: 0 }─
utop # List.tl [1;2;3;4];;
- : int list = [2; 3; 4]
```

- `partial application`特性，可以给一个多元函数部分参数得到另一个函数。
```Ocaml
─( 15:27:40 )─< command 1 >──────────────────────────────────────────────────────────────────────────────{ counter: 0 }─
utop # let add a b = a + b;;
val add : int -> int -> int = <fun>
─( 15:30:09 )─< command 2 >──────────────────────────────────────────────────────────────────────────────{ counter: 0 }─
utop # let add1 = add 1;;
val add1 : int -> int = <fun>
─( 15:30:14 )─< command 3 >──────────────────────────────────────────────────────────────────────────────{ counter: 0 }─
utop # add1 6;;
- : int = 7
```

- 元组`tuple`，可以是不同类型数据的组合，之前的`list`必须是相同类型元素的组合。
- `tuple`不具备`list`可以改变长度的特性，`tuple`的长度是固定的。
- 自定义枚举类型，注意首字母必须大写。
```Ocaml
─( 15:31:22 )─< command 4 >───────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────{ counter: 0 }─
utop # let tup = (7,"vincent",100.00);;
val tup : int * string * float = (7, "vincent", 100.)
─( 15:44:27 )─< command 14 >───────────────────────────────────────────────────────────────{ counter: 0 }─
utop # type gender = Male | Female | Helicopter;;
type gender = Male | Female | Helicopter
─( 15:44:34 )─< command 15 >───────────────────────────────────────────────────────────────{ counter: 0 }─
utop # let l =[Male;Female;Helicopter];;
val l : gender list = [Male; Female; Helicopter]
─( 15:46:07 )─< command 20 >───────────────────────────────────────────────────────────────{ counter: 0 }─
utop # type gender = Male | Female | Helicopter | Mixture of int * int * int;;
type gender = Male | Female | Helicopter | Mixture of int * int * int
─( 15:46:08 )─< command 21 >───────────────────────────────────────────────────────────────{ counter: 0 }─
utop # let l =[Male;Female;Helicopter;Mixture (1,2,6)];;
val l : gender list = [Male; Female; Helicopter; Mixture (1, 2, 6)]
```

- `Record`类型。
```Ocaml
─( 15:35:31 )─< command 7 >────────────────────────────────────────────────────────────────{ counter: 0 }─
utop # type person = {name:string;nickname:string;age:int;};;
type person = { name : string; nickname : string; age : int; }
─( 15:39:38 )─< command 8 >────────────────────────────────────────────────────────────────{ counter: 0 }─
utop # let vincent = {name = "vincent";nickname="embracer";age=20;};;
val vincent : person = {name = "vincent"; nickname = "embracer"; age = 20}
─( 17:15:25 )─< command 50 >─────────────────────────────────────────────────────────────────────────────{ counter: 0 }─
utop # type person = {name:string;nickname:string;mutable age:int;};;
type person = { name : string; nickname : string; mutable age : int; }
─( 17:15:31 )─< command 51 >─────────────────────────────────────────────────────────────────────────────{ counter: 0 }─
utop # let birthday p = p.age <- p.age + 1;;
val birthday : person -> unit = <fun>
─( 17:21:54 )─< command 52 >─────────────────────────────────────────────────────────────────────────────{ counter: 0 }─
utop # let vincent = {name = "vincent";nickname="embracer";age=20;};;
val vincent : person = {name = "vincent"; nickname = "embracer"; age = 20}
─( 17:22:50 )─< command 54 >─────────────────────────────────────────────────────────────────────────────{ counter: 0 }─
utop # birthday vincent;;
- : unit = ()
─( 17:23:02 )─< command 55 >─────────────────────────────────────────────────────────────────────────────{ counter: 0 }─
utop # vincent;;
- : person = {name = "vincent"; nickname = "embracer"; age = 21}
```

- 数据类型具有多态性和递归性
- 多态性：数据类型可以引用其他的子类型
- 递归性：数据类型可以递归地引用自身
```Ocaml
─( 15:49:02 )─< command 22 >──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────{ counter: 0 }─
utop # type 'a tree = | Leaf | Node of 'a tree * 'a * 'a tree;;
type 'a tree = Leaf | Node of 'a tree * 'a * 'a tree
─( 15:49:02 )─< command 23 >─────────────────────────────────────{ counter: 0 }─
utop # let rec total t = match t with | Leaf -> 0 | Node (l,x,r) -> total l + x + total r;;
val total : int tree -> int = <fun>
─( 16:43:13 )─< command 24 >─────────────────────────────────────{ counter: 0 }─
utop # let rec reverse t = match t with | Leaf -> Leaf | Node (l,x,r) -> Node (reverse r, x, reverse l);;
val reverse : 'a tree -> 'a tree = <fun>
─( 16:45:16 )─< command 25 >─────────────────────────────────────{ counter: 0 }─
utop # let t = Node(Node(Leaf,1,Leaf),2,Node(Node(Leaf,3,Leaf),4,Node(Leaf,5,Leaf)));;
val t : int tree =
  Node (Node (Leaf, 1, Leaf), 2,
   Node (Node (Leaf, 3, Leaf), 4, Node (Leaf, 5, Leaf)))
─( 16:48:00 )─< command 26 >─────────────────────────────────────{ counter: 0 }─
utop # let sum = total t;;
val sum : int = 15
─( 16:51:09 )─< command 27 >─────────────────────────────────────{ counter: 0 }─
utop # let mirror = reverse t;;
val mirror : int tree =
  Node (Node (Node (Leaf, 5, Leaf), 4, Node (Leaf, 3, Leaf)), 2,
   Node (Leaf, 1, Leaf))
─( 16:51:24 )─< command 28 >─────────────────────────────────────{ counter: 0 }─
utop # let sum = total mirror;;
val sum : int = 15
─( 16:51:59 )─< command 29 >─────────────────────────────────────{ counter: 0 }─
utop # t = reverse mirror;;
- : bool = true
```

- 错误处理
- 可以定义异常`exception`，同时为其添加子类型。
```Ocaml
─( 16:56:53 )─< command 32 >─────────────────────────────────────────────────────────────────────────────{ counter: 0 }─
utop # exception E;;
exception E
─( 16:57:01 )─< command 33 >─────────────────────────────────────────────────────────────────────────────{ counter: 0 }─
utop # exception E1 of string;;
exception E1 of string
─( 16:57:33 )─< command 35 >─────────────────────────────────────────────────────────────────────────────{ counter: 0 }─
utop # let divide a b = if b = 0 then raise (E1 "division by zero") else a / b;;
val divide : int -> int -> int = <fun>
─( 16:59:27 )─< command 37 >─────────────────────────────────────────────────────────────────────────────{ counter: 0 }─
utop # let result = try divide 1 0 with E1 _ -> 0;;
val result : int = 0
```

- `option`类型，类似`Rust`。
```Ocaml
─( 16:59:53 )─< command 38 >─────────────────────────────────────────────────────────────────────────────{ counter: 0 }─
utop # type 'a option = None | Some of 'a;;
type 'a option = None | Some of 'a
─( 17:00:06 )─< command 39 >─────────────────────────────────────────────────────────────────────────────{ counter: 0 }─
utop # let list_find_option p l = match List.find p l with | v -> Some(v) | exception Not_found -> None;;
val list_find_option : ('a -> bool) -> 'a list -> 'a option = <fun>
```

- 可变引用。
```Ocaml
─( 17:09:06 )─< command 41 >─────────────────────────────────────────────────────────────────────────────{ counter: 0 }─
utop # let r = ref 50;;
val r : int ref = {contents = 50}
─( 17:10:58 )─< command 42 >─────────────────────────────────────────────────────────────────────────────{ counter: 0 }─
utop # r := 100;;
- : unit = ()
─( 17:12:50 )─< command 43 >─────────────────────────────────────────────────────────────────────────────{ counter: 0 }─
utop # !r;;
- : int = 100
─( 17:13:01 )─< command 44 >─────────────────────────────────────────────────────────────────────────────{ counter: 0 }─
utop # let a = r;;
val a : int ref = {contents = 100}
─( 17:13:10 )─< command 45 >─────────────────────────────────────────────────────────────────────────────{ counter: 0 }─
utop # a := 100;;
- : unit = ()
─( 17:13:16 )─< command 46 >─────────────────────────────────────────────────────────────────────────────{ counter: 0 }─
utop # !r;;
- : int = 100
```

- 可变数组。
```Ocaml
─( 17:13:27 )─< command 47 >─────────────────────────────────────────────────────────────────────────────{ counter: 0 }─
utop # let arr = [|1;1;1|];;
val arr : int array = [|1; 1; 1|]
─( 17:13:35 )─< command 48 >─────────────────────────────────────────────────────────────────────────────{ counter: 0 }─
utop # arr.(0) <- 100;;
- : unit = ()
─( 17:15:13 )─< command 49 >─────────────────────────────────────────────────────────────────────────────{ counter: 0 }─
utop # arr;;
- : int array = [|100; 1; 1|]
```

- 函数示例：列表求和函数。
- Ocaml编译器会对模式匹配中忽略的情况发出警告。
```Ocaml
─( 21:01:33 )─< command 25 >──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────{ counter: 0 }─
utop # let rec total l =
match l with
| [] -> 0
| h :: t -> h + total t;;
val total : int list -> int = <fun>
─( 21:01:37 )─< command 26 >──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────{ counter: 0 }─
utop # total [1;2;3;4;5;6;7;8;9];;
- : int = 45
─( 21:05:14 )─< command 27 >──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────{ counter: 0 }─
utop # let rec total l =
match l with
| h :: t -> h + total t;;
Lines 2-3, characters 0-23:
Warning 8 [partial-match]: this pattern-matching is not exhaustive.
Here is an example of a case that is not matched:
[]
val total : int list -> int = <fun>
```

- 函数示例：映射函数。
```Ocaml
─( 21:05:31 )─< command 28 >──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────{ counter: 0 }─
utop # let rec map f l =
match l with
| [] -> []
| h :: t -> f h :: map f t;;
val map : ('a -> 'b) -> 'a list -> 'b list = <fun>
```

- 函数示例：快速排序（quicksort）算法。

```Ocaml
let rec quicksort = function
  | [] -> []  (* 空列表直接返回 *)
  | pivot :: rest ->
      let rec partition left right = function
        | [] -> (left, right)
        | x :: xs ->
            if x <= pivot then partition (x :: left) right xs
            else partition left (x :: right) xs
      in
      let (left, right) = partition [] [] rest in
      quicksort left @ [pivot] @ quicksort right
```

