---
title: Ocaml | Vincent's Technical Reports (Vol. 2)
date: 2025-07-04 00:30:00 +0800
categories: [Vincent's technical reports]
tags: [Ocaml]
pin: true
author: 宋建昊

toc: true
comments: true
typora-root-url: ../../framontom.github.io
math: false
mermaid: true
---
# Ocaml编程语言初探

## 安装

```
sudo apt install ocaml
sudo apt install utop
```
`UTop` 是 Ocaml的REPL(read evaluate print loop)，在 Ocaml中也叫做toplevel。

## 运行`UTop`

- 输入表达式，可以看到对应的带有类型的输出，需要记得在每行后结尾加两个分号";;"。
- 关闭`UTop`可以使用快捷键ctrl+d或者在`UTop`中执行`exit 0;;`。

```
─( 20:01:07 )─< command 0 >───────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────{ counter: 0 }─
utop # 1 + 2;;
- : int = 3
─( 20:01:07 )─< command 1 >───────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────{ counter: 0 }─
utop # exit 0;;
```

- 可以使用`let`定义变量，但Ocaml中的变量值是不可变的。
- `=`相当于C语言中的双等号`==`，代表判定等号两侧是否相等。
- 变量名必须以小写字母或者下划线开头。

```
─( 20:01:58 )─< command 0 >───────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────{ counter: 0 }─
utop # let x = 50;;
val x : int = 50
─( 20:01:58 )─< command 1 >───────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────{ counter: 0 }─
utop # x = 50;;
- : bool = true
─( 20:03:28 )─< command 2 >───────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────{ counter: 0 }─
utop # x = 500;;
- : bool = false
```

- 可以使用`let`+`in`的语法来计算函数值。
```
─( 20:03:54 )─< command 3 >───────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────{ counter: 0 }─
utop # let x = 100 in x * (x - 1);;
- : int = 9900
─( 20:15:07 )─< command 4 >───────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────{ counter: 0 }─
utop # let x = 10 in let y = 100 in x * y;;
- : int = 1000
```
- `let`也可以用来定义函数。
- 可以定义多元函数。
```
─( 20:17:51 )─< command 5 >───────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────{ counter: 0 }─
utop # let square x = x * x;;
val square : int -> int = <fun>
─( 20:17:53 )─< command 6 >───────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────{ counter: 0 }─
utop # let area = square 100;;
val area : int = 10000
─( 20:18:18 )─< command 7 >───────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────{ counter: 0 }─
utop # let multiply x y = x * y;;
val multiply : int -> int -> int = <fun>
```

- 可以使用`let rec`来定义递归函数。
```
─( 20:18:33 )─< command 8 >───────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────{ counter: 0 }─
utop # let rec range a b = if a > b then [] else a :: range (a + 1) b;;
val range : int -> int -> int list = <fun>
─( 20:20:21 )─< command 9 >───────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────{ counter: 0 }─
utop # let digits = range 0 9;;
val digits : int list = [0; 1; 2; 3; 4; 5; 6; 7; 8; 9]
```

- Ocaml是强静态类型语言，运行前编译器会自动进行类型推断，基本类型和其他语言类似。
- Ocaml中禁止隐式的类型转换。
```
─( 20:23:53 )─< command 10 >──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────{ counter: 0 }─
utop # 1 + 1;;
- : int = 2
─( 20:25:08 )─< command 11 >──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────{ counter: 0 }─
utop # 1.0 +. 1.0;;
- : float = 2.
─( 20:25:17 )─< command 12 >──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────{ counter: 0 }─
utop # false;;
- : bool = false
─( 20:25:47 )─< command 13 >──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────{ counter: 0 }─
utop # 's';;
- : char = 's'
─( 20:26:22 )─< command 14 >──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────{ counter: 0 }─
utop # "Vincent";;
- : string = "Vincent"
```

- 可以使用模式匹配方便地处理各种情况，非常适合`corner case`很多的情况。
```
─( 20:27:51 )─< command 15 >──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────{ counter: 0 }─
utop #  let rec factorial n =
match n with
| 0 | 1 -> 1
| _ -> n * factorial (n - 1);;
val factorial : int -> int = <fun>
─( 20:51:20 )─< command 16 >──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────{ counter: 0 }─
utop # factorial 5;;
- : int = 120
```

- 列表`list`
```
─( 20:52:55 )─< command 17 >──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────{ counter: 0 }─
utop # [];;
- : 'a list = []
─( 20:53:12 )─< command 18 >──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────{ counter: 0 }─
utop # [1;1];;
- : int list = [1; 1]
─( 20:55:47 )─< command 19 >──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────{ counter: 0 }─
utop # [true;false];;
- : bool list = [true; false]
─( 20:55:47 )─< command 20 >──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────{ counter: 0 }─
utop # [[1;2];[1;2]];;
- : int list list = [[1;2];[1;2]]
```
- 操作符有"::"(用来在列表前添加一个元素)和"@"(用来连接两个列表)。
- List的方法"hd"和"tl"可以分别获得列表头尾的元素。
```
─( 20:56:02 )─< command 21 >──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────{ counter: 0 }─
utop # 1 :: [2;3];;
- : int list = [1; 2; 3]
─( 20:56:43 )─< command 22 >──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────{ counter: 0 }─
utop # [1] @ [2;3];;
- : int list = [1; 2; 3]
─( 21:00:45 )─< command 23 >──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────{ counter: 0 }─
utop # List.hd [1;2;3;4];;
- : int = 1
─( 21:00:59 )─< command 24 >──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────{ counter: 0 }─
utop # List.tl [1;2;3;4];;
- : int list = [2; 3; 4]
```

- 列表求和函数(示例)
- Ocaml编译器会对模式匹配中忽略的情况发出警告
```
─( 21:01:33 )─< command 25 >──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────{ counter: 0 }─
utop # let rec total l =
match l with
| [] -> 0
| h :: t -> h + total t;;
val total : int list -> int = <fun>
─( 21:01:37 )─< command 26 >──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────{ counter: 0 }─
utop # total [1;2;3;4;5;6;7;8;9];;
- : int = 45
─( 21:05:14 )─< command 27 >──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────{ counter: 0 }─
utop # let rec total l =
match l with
| h :: t -> h + total t;;
Lines 2-3, characters 0-23:
Warning 8 [partial-match]: this pattern-matching is not exhaustive.
Here is an example of a case that is not matched:
[]
val total : int list -> int = <fun>
```

- 映射函数(示例)
```
─( 21:05:31 )─< command 28 >──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────{ counter: 0 }─
utop # let rec map f l =
match l with
| [] -> []
| h :: t -> f h :: map f t;;
val map : ('a -> 'b) -> 'a list -> 'b list = <fun>
```