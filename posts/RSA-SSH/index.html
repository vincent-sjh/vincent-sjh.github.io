<!DOCTYPE html><html lang="zh-CN" ><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="theme-color" media="(prefers-color-scheme: light)" content="#f7f7f7"><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1b1b1e"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="black-translucent"><meta name="viewport" content="width=device-width, user-scalable=no initial-scale=1, shrink-to-fit=no, viewport-fit=cover" ><meta name="generator" content="Jekyll v4.4.1" /><meta property="og:title" content="RSA &amp; SSH Vincent’s Technical Reports (Vol. 3)" /><meta name="author" content="宋建昊" /><meta property="og:locale" content="zh_CN" /><meta name="description" content="RSA and SSH RSA加密算法详解 简介" /><meta property="og:description" content="RSA and SSH RSA加密算法详解 简介" /><link rel="canonical" href="https://vincent-sjh.github.io/homepage/index.html/posts/RSA-SSH/" /><meta property="og:url" content="https://vincent-sjh.github.io/homepage/index.html/posts/RSA-SSH/" /><meta property="og:site_name" content="宋建昊" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2025-07-26T16:30:00+00:00" /><meta name="twitter:card" content="summary" /><meta property="twitter:title" content="RSA &amp; SSH Vincent’s Technical Reports (Vol. 3)" /><meta name="twitter:site" content="@si57311" /><meta name="twitter:creator" content="@宋建昊" /> <script type="application/ld+json"> {"@context":"https://schema.org","@type":"BlogPosting","author":{"@type":"Person","name":"宋建昊"},"dateModified":"2025-08-13T05:10:48+00:00","datePublished":"2025-07-26T16:30:00+00:00","description":"RSA and SSH RSA加密算法详解 简介","headline":"RSA &amp; SSH Vincent’s Technical Reports (Vol. 3)","mainEntityOfPage":{"@type":"WebPage","@id":"https://vincent-sjh.github.io/homepage/index.html/posts/RSA-SSH/"},"url":"https://vincent-sjh.github.io/homepage/index.html/posts/RSA-SSH/"}</script><title>RSA & SSH | Vincent's Technical Reports (Vol. 3) | 宋建昊</title><link rel="apple-touch-icon" sizes="180x180" href="/assets/img/favicons/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="/assets/img/favicons/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="/assets/img/favicons/favicon-16x16.png"><link rel="manifest" href="/assets/img/favicons/site.webmanifest"><link rel="shortcut icon" href="/assets/img/favicons/favicon.ico"><meta name="apple-mobile-web-app-title" content="宋建昊"><meta name="application-name" content="宋建昊"><meta name="msapplication-TileColor" content="#da532c"><meta name="msapplication-config" content="/assets/img/favicons/browserconfig.xml"><meta name="theme-color" content="#ffffff"><link rel="preconnect" href="https://fonts.googleapis.com" ><link rel="dns-prefetch" href="https://fonts.googleapis.com" ><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin><link rel="dns-prefetch" href="https://fonts.gstatic.com" crossorigin><link rel="preconnect" href="https://fonts.googleapis.com" ><link rel="dns-prefetch" href="https://fonts.googleapis.com" ><link rel="preconnect" href="https://cdn.jsdelivr.net" ><link rel="dns-prefetch" href="https://cdn.jsdelivr.net" ><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Lato&family=Source+Sans+Pro:wght@400;600;700;900&display=swap"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/css/bootstrap.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.11.2/css/all.min.css"><link rel="stylesheet" href="/assets/css/style.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/tocbot@4.20.1/dist/tocbot.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/magnific-popup@1/dist/magnific-popup.min.css"> <script src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script> <script type="text/javascript"> class ModeToggle { static get MODE_KEY() { return "mode"; } static get MODE_ATTR() { return "data-mode"; } static get DARK_MODE() { return "dark"; } static get LIGHT_MODE() { return "light"; } static get ID() { return "mode-toggle"; } constructor() { if (this.hasMode) { if (this.isDarkMode) { if (!this.isSysDarkPrefer) { this.setDark(); } } else { if (this.isSysDarkPrefer) { this.setLight(); } } } let self = this; /* always follow the system prefers */ this.sysDarkPrefers.addEventListener('change', () => { if (self.hasMode) { if (self.isDarkMode) { if (!self.isSysDarkPrefer) { self.setDark(); } } else { if (self.isSysDarkPrefer) { self.setLight(); } } self.clearMode(); } self.notify(); }); } /* constructor() */ get sysDarkPrefers() { return window.matchMedia("(prefers-color-scheme: dark)"); } get isSysDarkPrefer() { return this.sysDarkPrefers.matches; } get isDarkMode() { return this.mode === ModeToggle.DARK_MODE; } get isLightMode() { return this.mode === ModeToggle.LIGHT_MODE; } get hasMode() { return this.mode != null; } get mode() { return sessionStorage.getItem(ModeToggle.MODE_KEY); } /* get the current mode on screen */ get modeStatus() { if (this.isDarkMode || (!this.hasMode && this.isSysDarkPrefer)) { return ModeToggle.DARK_MODE; } else { return ModeToggle.LIGHT_MODE; } } setDark() { $('html').attr(ModeToggle.MODE_ATTR, ModeToggle.DARK_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); } setLight() { $('html').attr(ModeToggle.MODE_ATTR, ModeToggle.LIGHT_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); } clearMode() { $('html').removeAttr(ModeToggle.MODE_ATTR); sessionStorage.removeItem(ModeToggle.MODE_KEY); } /* Notify another plugins that the theme mode has changed */ notify() { window.postMessage({ direction: ModeToggle.ID, message: this.modeStatus }, "*"); } flipMode() { if (this.hasMode) { if (this.isSysDarkPrefer) { if (this.isLightMode) { this.clearMode(); } else { this.setLight(); } } else { if (this.isDarkMode) { this.clearMode(); } else { this.setDark(); } } } else { if (this.isSysDarkPrefer) { this.setLight(); } else { this.setDark(); } } this.notify(); } /* flipMode() */ } /* ModeToggle */ const modeToggle = new ModeToggle(); </script><body data-topbar-visible="true"><div id="sidebar" class="d-flex flex-column align-items-end"><div class="profile-wrapper text-center"><div id="avatar"> <a href="/" class="mx-auto"> <img src="/assets/config/avatar.jpg" alt="avatar" onerror="this.style.display='none'"> </a></div><div class="site-title"> <a href="/">宋建昊</a></div><div class="site-subtitle font-italic">We paint the world with our colors and everyone will know.</div></div><ul class="w-100"><li class="nav-item"> <a href="/" class="nav-link"> <i class="fa-fw fas fa-home ml-xl-3 mr-xl-3 unloaded"></i> <span>首页</span> </a><li class="nav-item"> <a href="/archives/" class="nav-link"> <i class="fa-fw fas fa-archive ml-xl-3 mr-xl-3 unloaded"></i> <span>归档</span> </a><li class="nav-item"> <a href="/categories/" class="nav-link"> <i class="fa-fw fas fa-stream ml-xl-3 mr-xl-3 unloaded"></i> <span>分类</span> </a><li class="nav-item"> <a href="/tags/" class="nav-link"> <i class="fa-fw fas fa-tags ml-xl-3 mr-xl-3 unloaded"></i> <span>标签</span> </a><li class="nav-item"> <a href="/about/" class="nav-link"> <i class="fa-fw fas fa-info ml-xl-3 mr-xl-3 unloaded"></i> <span>关于</span> </a></ul><div class="sidebar-bottom mt-auto d-flex flex-wrap justify-content-center align-items-center"> <button class="mode-toggle btn" aria-label="Switch Mode"> <i class="fas fa-adjust"></i> </button> <span class="icon-border"></span> <a href="https://github.com/vincent-sjh" aria-label="github" target="_blank" rel="noopener noreferrer"> <i class="fab fa-github"></i> </a> <a href="https://twitter.com/si57311" aria-label="twitter" target="_blank" rel="noopener noreferrer"> <i class="fab fa-twitter"></i> </a> <a href="javascript:location.href = 'mailto:' + ['songjh22','mails.tsinghua.edu.cn'].join('@')" aria-label="email" > <i class="fas fa-envelope"></i> </a> <a href="/feed.xml" aria-label="rss" > <i class="fas fa-rss"></i> </a></div></div><div id="topbar-wrapper"><div id="topbar" class="container d-flex align-items-center justify-content-between h-100 pl-3 pr-3 pl-md-4 pr-md-4"> <span id="breadcrumb"> <span> <a href="/"> 首页 </a> </span> <span>RSA & SSH | Vincent's Technical Reports (Vol. 3)</span> </span> <i id="sidebar-trigger" class="fas fa-bars fa-fw"></i><div id="topbar-title"> 文章</div><i id="search-trigger" class="fas fa-search fa-fw"></i> <span id="search-wrapper" class="align-items-center"> <i class="fas fa-search fa-fw"></i> <input class="form-control" id="search-input" type="search" aria-label="search" autocomplete="off" placeholder="搜索..."> </span> <span id="search-cancel" >取消</span></div></div><div id="main-wrapper" class="d-flex justify-content-center"><div id="main" class="container pl-xl-4 pr-xl-4"><div class="row"><div id="core-wrapper" class="col-12 col-lg-11 col-xl-9 pr-xl-4"><div class="post pl-1 pr-1 pl-md-2 pr-md-2"><h1 data-toc-skip>RSA & SSH | Vincent's Technical Reports (Vol. 3)</h1><div class="post-meta text-muted"> <span> 发表于 <em class="" data-ts="1753547400" data-df="YYYY/MM/DD" data-toggle="tooltip" data-placement="bottom"> 2025/07/26 </em> </span> <span> 更新于 <em class="" data-ts="1755061848" data-df="YYYY/MM/DD" data-toggle="tooltip" data-placement="bottom"> 2025/08/13 </em> </span><div class="d-flex justify-content-between"> <span> 作者 <em> <a href=""></a> </em> </span><div> <span class="readtime" data-toggle="tooltip" data-placement="bottom" title="3852 字"> <em>21 分钟</em>阅读</span></div></div></div><div class="post-content"><h1 id="rsa-and-ssh">RSA and SSH</h1><h2 id="rsa加密算法详解"><span class="mr-2">RSA加密算法详解</span><a href="#rsa加密算法详解" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><h3 id="简介"><span class="mr-2">简介</span><a href="#简介" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p><code class="language-plaintext highlighter-rouge">RSA</code>加密算法是1977年由<code class="language-plaintext highlighter-rouge">Ron Rivest</code>、<code class="language-plaintext highlighter-rouge">Adi Shamir</code>和<code class="language-plaintext highlighter-rouge">Leonard Adleman</code>共同提出的一种非对称加密算法，算法名称取自三位发明者姓氏的首字母。RSA是目前应用最广泛的公钥密码体制，广泛用于数字签名、密钥交换和数据加密等领域。</p><p>非对称加密是指加密者与解密者使用的是不同的密钥，反之对称加密是指加密者和解密者使用相同的密钥。对称加密要求加密者和解密者共同事先约定好密钥，但在网络上进行这个过程保证不泄密存在一定难度，这就是选择非对称加密的原因。</p><p>RSA算法的安全性基于大整数分解的困难性，即对于两个大素数的乘积，要分解出这两个素数在计算上是困难的。</p><h3 id="算法原理"><span class="mr-2">算法原理</span><a href="#算法原理" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><h4 id="密钥生成"><span class="mr-2">密钥生成</span><a href="#密钥生成" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><p>RSA密钥生成过程包括以下步骤：</p><ol><li><strong>选择两个大素数</strong> <code class="language-plaintext highlighter-rouge">p</code> 和 <code class="language-plaintext highlighter-rouge">q</code>，通常长度为512位或更长。<li><strong>计算模数</strong> <code class="language-plaintext highlighter-rouge">n = p × q</code><li><strong>计算欧拉函数</strong> <code class="language-plaintext highlighter-rouge">φ(n) = φ(p)φ(q) = (p-1)(q-1)</code><li><strong>选择公钥指数</strong> <code class="language-plaintext highlighter-rouge">e</code>，一个素数满足 <code class="language-plaintext highlighter-rouge">1 &lt; e &lt; φ(n)</code> 且 <code class="language-plaintext highlighter-rouge">gcd(e, φ(n)) = 1</code><li><strong>计算私钥指数</strong> <code class="language-plaintext highlighter-rouge">d</code>，满足<code class="language-plaintext highlighter-rouge"> ed ≡ 1 (mod φ(n))</code></ol><p>获得公钥为<code class="language-plaintext highlighter-rouge"> (n, e)</code>，私钥为<code class="language-plaintext highlighter-rouge"> (n, d)</code>。</p><h4 id="加密和解密"><span class="mr-2">加密和解密</span><a href="#加密和解密" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><p>将所要传递的消息按照双方约定好的格式转换为一个小于<code class="language-plaintext highlighter-rouge">n</code>的整数<code class="language-plaintext highlighter-rouge">m</code> (若消息太长可以分为多段)。</p><p><strong>加密：</strong> 对每段消息<code class="language-plaintext highlighter-rouge">m</code>使用公钥<code class="language-plaintext highlighter-rouge">(n, e)</code>加密。</p>\[c = m^e \pmod{n}\]<p><strong>解密：</strong> 对每段消息<code class="language-plaintext highlighter-rouge">m</code>使用公钥<code class="language-plaintext highlighter-rouge">(n, e)</code>加密。</p>\[m = c^d \pmod{n}\]<h3 id="数学正确性证明"><span class="mr-2">数学正确性证明</span><a href="#数学正确性证明" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p><strong>Theory：</strong> \((m^e)^d \equiv m \pmod{n}\)</p><p>我们需要证明对于任意整数<code class="language-plaintext highlighter-rouge">m</code>，当<code class="language-plaintext highlighter-rouge">p</code>和<code class="language-plaintext highlighter-rouge">q</code>为不同素数，且<code class="language-plaintext highlighter-rouge">e</code> 和<code class="language-plaintext highlighter-rouge">d</code>为满足\(ed \equiv 1 \pmod{\lambda(pq)}\) 的正整数时，有：</p>\[(m^e)^d \equiv m \pmod{pq}\]<p>根据<code class="language-plaintext highlighter-rouge">Carmichael</code>函数的定义，存在非负整数<code class="language-plaintext highlighter-rouge">h</code>和<code class="language-plaintext highlighter-rouge">k</code>，使得：</p>\[ed - 1 = h(p-1) = k(q-1)\]<p>为了证明 \((m^e)^d \equiv m \pmod{pq}\)</p><p>根据中国剩余定理（<code class="language-plaintext highlighter-rouge">CRT</code>），只需分别证明：</p>\[(m^e)^d \equiv m \pmod{p}\] \[(m^e)^d \equiv m \pmod{q}\]<p>由于<code class="language-plaintext highlighter-rouge">p</code>和<code class="language-plaintext highlighter-rouge">q</code>是不同素数，若上述两个同余成立，则：</p>\[(m^e)^d \equiv m \pmod{pq}\]<p>模<code class="language-plaintext highlighter-rouge">p</code>的证明分两种情况讨论：</p><ol><li><p>若<code class="language-plaintext highlighter-rouge">m</code>是<code class="language-plaintext highlighter-rouge">p</code>的倍数，等号两侧均为均为<code class="language-plaintext highlighter-rouge">p</code>的倍数。因此：</p>\[m^{ed} \equiv 0 \equiv m \pmod{p}\]<li><p>若<code class="language-plaintext highlighter-rouge">m</code>不是<code class="language-plaintext highlighter-rouge">p</code>的倍数，根据费马小定理，对于与<code class="language-plaintext highlighter-rouge">p</code>互质的<code class="language-plaintext highlighter-rouge">m</code>，有</p>\[\ m^{p-1} \equiv 1 \pmod{p} \\]<p>由于\(ed - 1 = h(p-1) = k(q-1)\)</p><p>我们得到：</p>\[m^{ed} = m^{ed-1} \cdot m = m^{h(p-1)} \cdot m = (m^{p-1})^h \cdot m\]<p>代入费马小定理 ( m^{p-1} \equiv 1 \pmod{p} )，有：</p>\[(m^{p-1})^h \equiv 1^h \equiv 1 \pmod{p}\]<p>因此：</p>\[m^{ed} \equiv 1 \cdot m \equiv m \pmod{p}\]</ol><p>综合两种情况，均有：</p>\[m^{ed} \equiv m \pmod{p}\]<p>模<code class="language-plaintext highlighter-rouge">q</code>的证明同理。</p><p>根据中国剩余定理，存在唯一解使得：</p>\[(m^e)^d = m^{ed} \equiv m \pmod{pq}\]<p>证明完毕。</p><h3 id="主要攻击方案与安全性分析"><span class="mr-2">主要攻击方案与安全性分析</span><a href="#主要攻击方案与安全性分析" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><h4 id="1-小公钥指数攻击低加密指数攻击"><span class="mr-2">1. 小公钥指数攻击（低加密指数攻击）</span><a href="#1-小公钥指数攻击低加密指数攻击" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><p>当公钥指数 <code class="language-plaintext highlighter-rouge">e</code> 很小（如 <code class="language-plaintext highlighter-rouge">e = 3</code>）且明文 <code class="language-plaintext highlighter-rouge">m</code> 相对<code class="language-plaintext highlighter-rouge">n</code>也较小时，可能存在安全风险。</p><p><strong>攻击原理</strong>：<br /> 攻击者可以直接计算：</p>\[c = m^e \pmod{n}\] \[m^e = c + kn\] \[m = (c+kn)^{1/e}\]<p>上述情况中，<code class="language-plaintext highlighter-rouge">k</code>就比较小，攻击者可以从小到大枚举<code class="language-plaintext highlighter-rouge">k</code>，依次开方直至开出整数为止。</p><h5 id="明文长度与攻击的关系"><span class="mr-2">明文长度与攻击的关系</span><a href="#明文长度与攻击的关系" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h5><p>假设明文 <code class="language-plaintext highlighter-rouge">m</code> 和模数 <code class="language-plaintext highlighter-rouge">n</code> 位数相同（如 2048 位，约 600 十进制位），即使 <code class="language-plaintext highlighter-rouge">e = 3</code>，计算暴力枚举复杂度极高（指数级），理论上不可行。但问题在于，实际明文往往远短于 <code class="language-plaintext highlighter-rouge">n</code>，例如一条短消息（如 128 位）。若直接加密短明，攻击者可轻松计算立方根。此外，短明文可能具有可预测的结构（如固定格式的协议消息），进一步降低攻击难度。</p><h5 id="填充的作用"><span class="mr-2">填充的作用</span><a href="#填充的作用" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h5><p>填充（Padding）通过在明文 <code class="language-plaintext highlighter-rouge">m</code> 前添加随机数据或结构化数据，使其长度接近或等于 <code class="language-plaintext highlighter-rouge">n</code> 的位数，并增加随机性，从而防止小公钥指数攻击。RSA 常用的填充模式包括：</p><ul><li><strong>RSA_PKCS1_PADDING</strong>：在明文前添加随机字节，确保总长度接近 <code class="language-plaintext highlighter-rouge">n</code>，并包含固定分隔符以验证解密正确性。<li><strong>RSA_PKCS1_OAEP_PADDING</strong>：基于最优非对称加密填充<code class="language-plaintext highlighter-rouge">OAEP</code>，结合随机种子和哈希函数，生成高度随机的填充数据，安全性更高。<li><strong>RSA_NO_PADDING</strong>：无填充，直接加密原始明文，极易受到小公钥指数攻击。</ul><p>填充的具体作用如下：</p><ol><li><p><strong>增加明文长度</strong>：<br /> 填充使明文 <code class="language-plaintext highlighter-rouge">m</code> 的有效值接近或超过 <code class="language-plaintext highlighter-rouge">n</code>。</p><li><p><strong>引入随机性</strong>：<br /> 填充（如 OAEP）通过随机种子和哈希函数使每次加密的 <code class="language-plaintext highlighter-rouge">m</code> 不同，即使原始消息相同，密文 <code class="language-plaintext highlighter-rouge">c</code> 也各异。这破坏了攻击者利用密文确定性（如预计算表）的可能性。</p><li><p><strong>防止确定性攻击</strong>：<br /> 无填充（<code class="language-plaintext highlighter-rouge">RSA_NO_PADDING</code>）的明文若结构固定（如协议头），攻击者可通过选择明文攻击构建密文-明文对。填充引入的随机性和结构（如 OAEP 的哈希校验）使此类攻击失效。</p></ol><h5 id="块加密与填充"><span class="mr-2">块加密与填充</span><a href="#块加密与填充" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h5><p>当明文长度超过 <code class="language-plaintext highlighter-rouge">n</code> 的位数时，需将其分割为多个块，每个块长度小于 <code class="language-plaintext highlighter-rouge">n</code>，分别填充后加密，称为块加密。这类似于对称加密的分组加密，但 RSA 的块加密仍是非对称加密。例如，2048 位模数 <code class="language-plaintext highlighter-rouge">n</code> 限制单块明文小于 2048 位，填充（如 <code class="language-plaintext highlighter-rouge">OAEP</code>）确保每块长度接近 <code class="language-plaintext highlighter-rouge">n</code> 且随机化。</p><h5 id="结论"><span class="mr-2">结论</span><a href="#结论" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h5><p>小公钥指数攻击的根源在于明文 <code class="language-plaintext highlighter-rouge">m</code> 过短或缺乏随机性，导致 <code class="language-plaintext highlighter-rouge">m^e</code> 不触发模运算或易于猜测。填充方案（如 <code class="language-plaintext highlighter-rouge">RSA_PKCS1_OAEP_PADDING</code>）通过拉长明文长度、引入随机性和验证结构，有效防止此类攻击。即使使用 <code class="language-plaintext highlighter-rouge">e = 3</code>，只要正确实施填充，RSA 加密仍可保持安全。然而，<code class="language-plaintext highlighter-rouge">e = 65537</code> 是更推荐的选择，因为它在效率和安全性之间取得了更好平衡，且在实践中已成为标准。</p><h4 id="2-共模攻击-common-modulus-attack"><span class="mr-2">2. 共模攻击 (Common Modulus Attack)</span><a href="#2-共模攻击-common-modulus-attack" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><p>当两个用户使用相同的模数 <code class="language-plaintext highlighter-rouge">n</code> 但不同的公钥指数 <code class="language-plaintext highlighter-rouge">e_1</code> 和 <code class="language-plaintext highlighter-rouge">e_2</code> 时，如果 <code class="language-plaintext highlighter-rouge">gcd(e_1, e_2) = 1</code>，攻击者可以在不知道私钥的情况下解密消息。</p><p><strong>攻击过程</strong>：</p><p>设同一明文 <code class="language-plaintext highlighter-rouge">m</code> 被两个公钥加密：</p><p>\(c_1 \equiv m^{e_1} \pmod{n}\) \(c_2 \equiv m^{e_2} \pmod{n}\)</p><p>如果 <code class="language-plaintext highlighter-rouge">gcd(e_1, e_2) = 1</code>，则存在整数 <code class="language-plaintext highlighter-rouge">s</code> 和 <code class="language-plaintext highlighter-rouge">t</code> （可以为负数，此时取逆元）使得：</p>\[s e_1 + t e_2 = 1\]<p>攻击者可以计算：</p>\[m \equiv c_1^s \cdot c_2^t \pmod{n}\]<p><strong>数学证明</strong>：</p>\[c_1^s \cdot c_2^t \equiv (m^{e_1})^s \cdot (m^{e_2})^t \equiv m^{s e_1 + t e_2} \equiv m^1 \equiv m \pmod{n}\]<h4 id="3-广播攻击-håstad-broadcast-attack"><span class="mr-2">3. 广播攻击 (Håstad Broadcast Attack)</span><a href="#3-广播攻击-håstad-broadcast-attack" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><p>当使用小的公钥指数（通常 <code class="language-plaintext highlighter-rouge">e = 3</code>）向多个接收者发送相同消息时，攻击者可以利用中国剩余定理恢复明文。</p><p><strong>攻击条件</strong>：</p><ul><li>使用相同的小指数 <code class="language-plaintext highlighter-rouge">e</code>。<li>向至少 <code class="language-plaintext highlighter-rouge">e</code> 个不同的接收者发送相同消息。<li>各接收者使用不同的模数。</ul><p><strong>攻击过程</strong>：</p><p>设明文 <code class="language-plaintext highlighter-rouge">m</code> 被发送给 <code class="language-plaintext highlighter-rouge">e</code> 个接收者，得到密文：</p><p>\(c_1 \equiv m^e \pmod{n_1}\) \(c_2 \equiv m^e \pmod{n_2}\) \(\vdots\) \(c_e \equiv m^e \pmod{n_e}\)</p><p>如果各模数互质，使用中国剩余定理可以求出：</p>\[x \equiv m^e \pmod{n_1 n_2 \cdots n_e}\]<p>因此可以枚举<code class="language-plaintext highlighter-rouge">k</code>来破解：</p>\[m = (x+kn_1 n_2 \cdots n_e)^{1/e}\]<h4 id="4-量子计算威胁"><span class="mr-2">4. 量子计算威胁</span><a href="#4-量子计算威胁" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><h4 id="shor-算法"><span class="mr-2">Shor 算法</span><a href="#shor-算法" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><p>Peter Shor 在 1994 年提出了一种量子算法，能够在多项式时间内分解大整数，这对 RSA 构成了根本性威胁。</p><p><strong>算法原理</strong>：</p><ol><li><p>将整数分解问题转化为寻找函数 <code class="language-plaintext highlighter-rouge">f(x) = a^x mod n</code> 的周期。</p><li><p>使用量子傅里叶变换找到周期 <code class="language-plaintext highlighter-rouge">r</code>。</p><li><p>如果 <code class="language-plaintext highlighter-rouge">r</code> 是偶数且</p>\[a^{r/2} \not\equiv -1 \pmod{n}\]<p>则 \(gcd(a^{r/2} \pm 1, n)\) 给出 <code class="language-plaintext highlighter-rouge">n</code> 的非平凡因子。</p></ol><p><strong>时间复杂度</strong>：<code class="language-plaintext highlighter-rouge">O((log n)^3)</code></p><p>虽然 Shor 算法在理论上可以破解 RSA，但目前的量子计算机还无法处理实际使用的 RSA 密钥长度。然而，随着量子计算技术的发展，这种威胁正在变得越来越现实。</p><h3 id="总结"><span class="mr-2">总结</span><a href="#总结" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>RSA算法作为最重要的公钥密码算法之一，在信息安全领域发挥着关键作用。虽然面临着各种攻击威胁，特别是量子计算的挑战，但通过合理的参数选择和安全实现，RSA仍然是当前最可靠的加密方案之一。随着后量子密码学的发展，未来可能需要新的算法来替代RSA。</p><h3 id="参考文献"><span class="mr-2">参考文献</span><a href="#参考文献" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><ul><li><a href="https://ctf-wiki.org/crypto/asymmetric/rsa/rsa_theory/">RSA 介绍 - CTF Wiki</a><li><a href="https://en.wikipedia.org/wiki/RSA_cryptosystem">RSA (cryptosystem) - Wikipedia</a><li><a href="https://www.wikiwand.com/en/articles/Shor's_algorithm">Shor’s algorithm - Wikiwand</a></ul><h2 id="ssh技术解析"><span class="mr-2">SSH技术解析</span><a href="#ssh技术解析" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><h3 id="什么是-ssh"><span class="mr-2">什么是 SSH？</span><a href="#什么是-ssh" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p><code class="language-plaintext highlighter-rouge">SSH</code>（<code class="language-plaintext highlighter-rouge">Secure Shell</code>）是一种加密的网络协议，用于在不安全的网络环境中实现计算机之间的安全通信和文件传输。它通过加密技术保障数据传输的安全性，广泛应用于远程登录、文件传输和端口转发等场景。SSH 的出现解决了早期互联网明文传输带来的安全隐患，为用户和服务器之间的通信提供了可靠的保护。</p><h3 id="ssh-的起源"><span class="mr-2">SSH 的起源</span><a href="#ssh-的起源" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p><code class="language-plaintext highlighter-rouge">SSH</code> 由芬兰学者<code class="language-plaintext highlighter-rouge"> Tatu Ylönen </code>于 1995 年开发，最初版本为 <code class="language-plaintext highlighter-rouge">SSH-1</code>，旨在通过加密登录信息和传输内容来确保通信安全。<code class="language-plaintext highlighter-rouge">Tatu Ylönen</code> 将代码免费发布，引发了全球开发者的广泛关注和使用。随后，<code class="language-plaintext highlighter-rouge">SSH</code>协议不断演进，支持多种加密算法，并衍生出多种实现，其中由 <code class="language-plaintext highlighter-rouge">OpenBSD</code> 项目开发的<code class="language-plaintext highlighter-rouge"> OpenSSH</code> 是最流行的开源实现。你可以通过 <a href="https://www.openssh.com/">OpenSSH 官方网站</a> 或 <a href="https://github.com/openssh/openssh-portable">GitHub 仓库</a> 获取更多信息。</p><p>现今，<code class="language-plaintext highlighter-rouge">OpenSSH</code> 已内置于大多数<code class="language-plaintext highlighter-rouge"> Linux</code> 发行版中，<code class="language-plaintext highlighter-rouge">Windows</code> 从 <code class="language-plaintext highlighter-rouge">Windows 10</code> 版本 <code class="language-plaintext highlighter-rouge">1809</code> 起也默认支持<code class="language-plaintext highlighter-rouge"> SSH</code>。可以通过以下命令检查系统中是否安装了 <code class="language-plaintext highlighter-rouge">SSH</code>：</p><div class="language-bash highlighter-rouge"><div class="code-header"> <span data-label-text="Shell"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="nv">$ </span>ssh
</pre></table></code></div></div><h3 id="ssh-的工作原理"><span class="mr-2">SSH 的工作原理</span><a href="#ssh-的工作原理" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p><code class="language-plaintext highlighter-rouge">SSH</code> 的核心在于通过加密算法保护数据传输安全，主要采用以下两种加密方式：</p><h4 id="1-对称加密"><span class="mr-2">1. 对称加密</span><a href="#1-对称加密" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><p>对称加密使用单一密钥在客户端（<code class="language-plaintext highlighter-rouge">Client</code>）和服务器（<code class="language-plaintext highlighter-rouge">Serve</code>r）之间加密和解密数据。<code class="language-plaintext highlighter-rouge">SSH</code> 的会话密钥即采用对称加密，因其加解密速度快，适合传输大量数据。然而，密钥需要在客户端和服务器之间共享，若密钥泄露，可能导致安全风险。</p><h4 id="2-非对称加密"><span class="mr-2">2. 非对称加密</span><a href="#2-非对称加密" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><p>非对称加密使用一对密钥：<strong>公钥</strong>和<strong>私钥</strong>。公钥用于加密数据，私钥用于解密。SSH 在用户认证阶段主要依赖非对称加密，其流程如下：</p><ol><li><strong>密码登录流程</strong>：<ul><li>客户端发起 <code class="language-plaintext highlighter-rouge">SSH</code> 连接请求（不含密码）。<li>服务器发送公钥给客户端。<li>客户端使用公钥加密密码并发送回服务器。<li>服务器使用私钥解密，验证密码是否匹配。<li>服务器返回验证结果。</ul><li><strong>公钥登录流程（免密登录）</strong>：<ul><li>客户端将公钥预存到服务器的 <code class="language-plaintext highlighter-rouge">~/.ssh/authorized_keys</code> 文件中。<li>客户端发起登录请求。<li>服务器生成随机数 <code class="language-plaintext highlighter-rouge">R</code>，用客户端公钥加密后发送。<li>客户端用私钥解密 <code class="language-plaintext highlighter-rouge">R</code>，结合会话密钥生成摘要 <code class="language-plaintext highlighter-rouge">Digest1</code> 并发送。<li>服务器生成摘要 <code class="language-plaintext highlighter-rouge">Digest2</code>，与 <code class="language-plaintext highlighter-rouge">Digest1</code> 比对，验证通过后允许登录。</ul></ol><p>非对称加密的优点是私钥无需在网络中传输，安全性更高，公钥登录方式也免去了频繁输入密码的麻烦。</p><h3 id="ssh-入门指南"><span class="mr-2">SSH 入门指南</span><a href="#ssh-入门指南" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><h4 id="基本登录"><span class="mr-2">基本登录</span><a href="#基本登录" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><p>要通过<code class="language-plaintext highlighter-rouge"> SSH</code> 登录远程主机，只需以下命令：</p><div class="language-bash highlighter-rouge"><div class="code-header"> <span data-label-text="Shell"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="nv">$ </span>ssh User@Host
</pre></table></code></div></div><ul><li><strong>User</strong>：远程主机的用户名。<li><strong>Host</strong>：远程主机的<code class="language-plaintext highlighter-rouge"> IP</code> 地址或域名。</ul><p>若用户名与本地相同，可省略 <code class="language-plaintext highlighter-rouge">User@</code> 部分：</p><div class="language-bash highlighter-rouge"><div class="code-header"> <span data-label-text="Shell"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="nv">$ </span>ssh Host
</pre></table></code></div></div><p>默认端口为<code class="language-plaintext highlighter-rouge"> 22</code>，若需指定其他端口，可使用 <code class="language-plaintext highlighter-rouge">-p</code> 参数：</p><div class="language-bash highlighter-rouge"><div class="code-header"> <span data-label-text="Shell"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="nv">$ </span>ssh <span class="nt">-p</span> 12345 User@Host
</pre></table></code></div></div><p>首次连接时，系统会提示主机真实性未验证，要求用户确认公钥指纹：</p><div class="language-bash highlighter-rouge"><div class="code-header"> <span data-label-text="Shell"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre>The authenticity of host <span class="s1">'8.8.8.8 (8.8.8.8)'</span> can<span class="s1">'t be established.
ECDSA key fingerprint is SHA256:/h8m94SK4xPttR+W5wZi+rQC8Dq3Rs6XSDhlzIKREI4.
Are you sure you want to continue connecting (yes/no/[fingerprint])?
</span></pre></table></code></div></div><p>输入 <code class="language-plaintext highlighter-rouge">yes</code> 后，<code class="language-plaintext highlighter-rouge">SSH</code> 会将主机公钥保存至 <code class="language-plaintext highlighter-rouge">~/.ssh/known_hosts</code>，后续连接将自动识别。</p><h4 id="密码登录"><span class="mr-2">密码登录</span><a href="#密码登录" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><p>若未配置公钥登录，系统会提示输入密码：</p><div class="language-bash highlighter-rouge"><div class="code-header"> <span data-label-text="Shell"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre>Password:
</pre></table></code></div></div><p>输入正确密码即可登录。</p><h4 id="公钥登录"><span class="mr-2">公钥登录</span><a href="#公钥登录" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><p>公钥登录需先生成密钥对并将公钥上传至服务器：</p><ol><li><strong>生成密钥对</strong>：<div class="language-bash highlighter-rouge"><div class="code-header"> <span data-label-text="Shell"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="nv">$ </span>ssh-keygen
</pre></table></code></div></div><p>默认生成 RSA 密钥对，存储在 <code class="language-plaintext highlighter-rouge">~/.ssh/id_rsa</code>（私钥）和 <code class="language-plaintext highlighter-rouge">~/.ssh/id_rsa.pub</code>（公钥）。可通过 <code class="language-plaintext highlighter-rouge">-t</code> 和 <code class="language-plaintext highlighter-rouge">-b</code> 参数指定算法和密钥长度：</p><div class="language-bash highlighter-rouge"><div class="code-header"> <span data-label-text="Shell"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="nv">$ </span>ssh-keygen <span class="nt">-t</span> ecdsa <span class="nt">-b</span> 384
</pre></table></code></div></div><li><p><strong>上传公钥</strong>： 使用以下命令将公钥追加到服务器的 <code class="language-plaintext highlighter-rouge">~/.ssh/authorized_keys</code>：</p><div class="language-bash highlighter-rouge"><div class="code-header"> <span data-label-text="Shell"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="nv">$ </span>ssh-copy-id User@Host
</pre></table></code></div></div><p>在 Windows 系统或不支持 <code class="language-plaintext highlighter-rouge">ssh-copy-id</code> 的环境中，可手动操作：</p><div class="language-bash highlighter-rouge"><div class="code-header"> <span data-label-text="Shell"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre><span class="nv">$ </span>scp <span class="nt">-P</span> &lt;port&gt; ~/.ssh/id_rsa.pub User@Host:~/.ssh/
<span class="nv">$ </span>ssh <span class="nt">-p</span> &lt;port&gt; User@Host
<span class="nv">$ </span><span class="nb">cat</span> ~/.ssh/id_rsa.pub <span class="o">&gt;&gt;</span> ~/.ssh/authorized_keys
</pre></table></code></div></div><li><p><strong>设置权限</strong>（可选）： 确保 <code class="language-plaintext highlighter-rouge">authorized_keys</code> 文件权限正确：</p><div class="language-bash highlighter-rouge"><div class="code-header"> <span data-label-text="Shell"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="nv">$ </span><span class="nb">chmod </span>600 ~/.ssh/authorized_keys
</pre></table></code></div></div><li><p><strong>验证配置文件</strong>： 检查服务器的 <code class="language-plaintext highlighter-rouge">/etc/ssh/sshd_config</code> 文件，确保以下配置未被注释：</p><div class="language-bash highlighter-rouge"><div class="code-header"> <span data-label-text="Shell"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre>RSAAuthentication <span class="nb">yes
</span>PubkeyAuthentication <span class="nb">yes
</span>AuthorizedKeysFile .ssh/authorized_keys
</pre></table></code></div></div></ol><p>完成以上步骤后，即可通过公钥免密登录。</p><h4 id="配置文件"><span class="mr-2">配置文件</span><a href="#配置文件" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><p>为简化登录流程，可在 <code class="language-plaintext highlighter-rouge">~/.ssh/config</code> 文件中配置主机别名：</p><div class="language-bash highlighter-rouge"><div class="code-header"> <span data-label-text="Shell"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre>Host example
    HostName example.com
    Port 2222
    User myuser
    IdentityFile ~/.ssh/id_rsa
</pre></table></code></div></div><p>配置后，可通过以下命令快速登录：</p><div class="language-bash highlighter-rouge"><div class="code-header"> <span data-label-text="Shell"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="nv">$ </span>ssh example
</pre></table></code></div></div><h4 id="文件传输"><span class="mr-2">文件传输</span><a href="#文件传输" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><p>SSH 提供 <code class="language-plaintext highlighter-rouge">scp</code> 命令用于文件传输。例如，将本地文件 <code class="language-plaintext highlighter-rouge">test.cpp</code> 上传至服务器的 <code class="language-plaintext highlighter-rouge">/test/</code> 目录：</p><div class="language-bash highlighter-rouge"><div class="code-header"> <span data-label-text="Shell"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="nv">$ </span>scp <span class="nt">-P</span> 12222 ./test.cpp User@8.8.8.8:/test/
</pre></table></code></div></div><h4 id="端口转发"><span class="mr-2">端口转发</span><a href="#端口转发" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><p>SSH 支持多种端口转发方式：</p><ol><li><strong>动态端口绑定</strong>：<div class="language-bash highlighter-rouge"><div class="code-header"> <span data-label-text="Shell"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="nv">$ </span>ssh <span class="nt">-D</span> 8080 User@Host
</pre></table></code></div></div><p>将本地 8080 端口绑定到远程主机，实现 SOCKS 代理。</p><li><p><strong>本地端口转发</strong>：</p><div class="language-bash highlighter-rouge"><div class="code-header"> <span data-label-text="Shell"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="nv">$ </span>ssh <span class="nt">-L</span> 8080:host2:22 host3
</pre></table></code></div></div><p>将本地 8080 端口的数据通过 <code class="language-plaintext highlighter-rouge">host3</code> 转发至 <code class="language-plaintext highlighter-rouge">host2</code> 的 22 端口。</p><li><strong>远程端口转发</strong>：<div class="language-bash highlighter-rouge"><div class="code-header"> <span data-label-text="Shell"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="nv">$ </span>ssh <span class="nt">-R</span> 8080:host2:22 host1
</pre></table></code></div></div><p>将 <code class="language-plaintext highlighter-rouge">host1</code> 的 <code class="language-plaintext highlighter-rouge">8080</code> 端口数据通过 <code class="language-plaintext highlighter-rouge">host3</code> 转发至 <code class="language-plaintext highlighter-rouge">host2</code> 的 22 端口，适用于内网场景。</p></ol><h3 id="参考资料"><span class="mr-2">参考资料</span><a href="#参考资料" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><ul><li><a href="https://www.ruanyifeng.com/blog/2011/12/ssh_remote_login.html">SSH 原理与运用（一）：远程登录</a><li><a href="https://www.ruanyifeng.com/blog/2011/12/ssh_port_forwarding.html">SSH 原理与运用（二）：远程操作与端口转发</a><li><a href="https://www.cnblogs.com/Jamesblog/p/17329895.html">超详细的图解 SSH 原理</a><li><a href="https://www.openssh.com/">OpenSSH 官方网站</a><li><a href="https://github.com/openssh/openssh-portable">OpenSSH GitHub 仓库</a></ul></div><div class="post-tail-wrapper text-muted"><div class="post-meta mb-3"> <i class="far fa-folder-open fa-fw mr-1"></i> <a href='/categories/vincent-s-technical-reports/'>Vincent's Technical Reports</a></div><div class="post-tags"> <i class="fa fa-tags fa-fw mr-1"></i> <a href="/tags/rsa/" class="post-tag no-text-decoration" >RSA</a> <a href="/tags/ssh/" class="post-tag no-text-decoration" >SSH</a> <a href="/tags/number-theory/" class="post-tag no-text-decoration" >Number Theory</a> <a href="/tags/network/" class="post-tag no-text-decoration" >Network</a></div><div class="post-tail-bottom d-flex justify-content-between align-items-center mt-3 pt-5 pb-2"><div class="license-wrapper"> 本文由作者按照 <a href="https://creativecommons.org/licenses/by/4.0/"> CC BY 4.0 </a> 进行授权</div><div class="share-wrapper"> <span class="share-label text-muted mr-1">分享</span> <span class="share-icons"> <a href="https://twitter.com/intent/tweet?text=RSA%20&%20SSH%20%7C%20Vincent's%20Technical%20Reports%20(Vol.%203)%20-%20%E5%AE%8B%E5%BB%BA%E6%98%8A&url=https%3A%2F%2Fvincent-sjh.github.io%2Fhomepage%2Findex.html%2Fposts%2FRSA-SSH%2F" data-toggle="tooltip" data-placement="top" title="Twitter" target="_blank" rel="noopener" aria-label="Twitter"> <i class="fa-fw fab fa-twitter"></i> </a> <a href="https://www.facebook.com/sharer/sharer.php?title=RSA%20&%20SSH%20%7C%20Vincent's%20Technical%20Reports%20(Vol.%203)%20-%20%E5%AE%8B%E5%BB%BA%E6%98%8A&u=https%3A%2F%2Fvincent-sjh.github.io%2Fhomepage%2Findex.html%2Fposts%2FRSA-SSH%2F" data-toggle="tooltip" data-placement="top" title="Facebook" target="_blank" rel="noopener" aria-label="Facebook"> <i class="fa-fw fab fa-facebook-square"></i> </a> <a href="https://t.me/share/url?url=https%3A%2F%2Fvincent-sjh.github.io%2Fhomepage%2Findex.html%2Fposts%2FRSA-SSH%2F&text=RSA%20&%20SSH%20%7C%20Vincent's%20Technical%20Reports%20(Vol.%203)%20-%20%E5%AE%8B%E5%BB%BA%E6%98%8A" data-toggle="tooltip" data-placement="top" title="Telegram" target="_blank" rel="noopener" aria-label="Telegram"> <i class="fa-fw fab fa-telegram"></i> </a> <i id="copy-link" class="fa-fw fas fa-link small" data-toggle="tooltip" data-placement="top" title="分享链接" data-title-succeed="链接已复制！"> </i> </span></div></div></div></div></div><div id="panel-wrapper" class="col-xl-3 pl-2 text-muted"><div class="access"><div id="access-lastmod" class="post"><div class="panel-heading">最近更新</div><ul class="post-content pl-0 pb-1 ml-1 mt-2"><li><a href="/posts/AI-IDE/">Productivity Tool Recommendations | Workflow Wizards (Vol. 1)</a><li><a href="/posts/Web-Page/">How can we see a web page? | Vincent's Technical Reports (Vol. 5)</a><li><a href="/posts/RSA-SSH/">RSA & SSH | Vincent's Technical Reports (Vol. 3)</a><li><a href="/posts/AI-Detector-Humanizer/">AI Detector & Humanizer | Vincent's Technical Reports (Vol. 4)</a><li><a href="/posts/Reverse_Engineering/">A Try on Reverse Engineering | Vincent's Technical Reports (Vol. 1)</a></ul></div><div id="access-tags"><div class="panel-heading">热门标签</div><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/llm/">LLM</a> <a class="post-tag" href="/tags/network/">Network</a> <a class="post-tag" href="/tags/ai/">AI</a> <a class="post-tag" href="/tags/decompiler/">Decompiler</a> <a class="post-tag" href="/tags/detector/">Detector</a> <a class="post-tag" href="/tags/hello-world/">Hello World</a> <a class="post-tag" href="/tags/humanizer/">Humanizer</a> <a class="post-tag" href="/tags/number-theory/">Number Theory</a> <a class="post-tag" href="/tags/ocaml/">Ocaml</a> <a class="post-tag" href="/tags/programming-language/">Programming Language</a></div></div></div><div id="toc-wrapper" class="pl-0 pr-4 mb-5"><div class="panel-heading pl-3 pt-2 mb-2">文章内容</div><nav id="toc"></nav></div><script src="https://cdn.jsdelivr.net/npm/tocbot@4.20.1/dist/tocbot.min.js"></script></div></div><div class="row"><div id="tail-wrapper" class="col-12 col-lg-11 col-xl-9 pl-3 pr-3 pr-xl-4 mt-5"><div id="related-posts" class="mb-2 mb-sm-4"><h3 class="pt-2 mb-4 ml-1" data-toc-skip>相关文章</h3><div class="card-deck mb-4"><div class="card"> <a href="/posts/Web-Page/"><div class="card-body"> <em class="small" data-ts="1755016200" data-df="YYYY/MM/DD" > 2025/08/12 </em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>How can we see a web page? | Vincent's Technical Reports (Vol. 5)</h3><div class="text-muted small"><p> 摘要 当用户在浏览器地址栏输入URL并按下回车键时，一个复杂的网络通信过程随即启动。本文将系统性地分析从URL解析到网页完整渲染的全过程，深入剖析协议栈各层的协同工作机制，呈现现代互联网通信的技术架构。 1 应用层协议与资源定位 1.1 URL 统一资源定位符（Uniform Resource Locator, URL）是互联网资源的标准寻址方案。标准语法结构如下： 1 2 3 s...</p></div></div></a></div><div class="card"> <a href="/posts/Reverse_Engineering/"><div class="card-body"> <em class="small" data-ts="1748363400" data-df="YYYY/MM/DD" > 2025/05/27 </em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>A Try on Reverse Engineering | Vincent's Technical Reports (Vol. 1)</h3><div class="text-muted small"><p> 一次有趣的逆向工程经历 前因 在五道口技术学院某抽象院系的某课程的一次作业中，出现了有趣的情况。 作业要求监测某可执行文件运行过程中的数据，再用数据推测得到助教提前设置好的两个信息。 提供给同学们下载的是编译好的可执行文件，而不是源代码，不然可以直接阅读源码获得答案。 同时，这个可执行文件运行需要一个参数，助教规定每个同学将参数设置为自己的学号。 这是为了保证同学们的答案不全相同...</p></div></div></a></div><div class="card"> <a href="/posts/Ocaml-1/"><div class="card-body"> <em class="small" data-ts="1751560200" data-df="YYYY/MM/DD" > 2025/07/03 </em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>Ocaml(1) | Vincent's Technical Reports (Vol. 2)</h3><div class="text-muted small"><p> Ocaml编程语言初探 简介 OCaml (Objective Caml)是一种功能强大、兼具函数式、命令式和面向对象编程特性的通用编程语言。它由 INRIA(法国国家信息与自动化研究所)开发，最初设计于 1980 年代，是 Caml (Categorical Abstract Machine Language)语言的扩展版本，而 Caml 是 ML(Meta Language)语言家族...</p></div></div></a></div></div></div><div class="post-navigation d-flex justify-content-between"> <a href="/posts/AI-IDE/" class="btn btn-outline-primary" prompt="上一篇"><p>Productivity Tool Recommendations | Workflow Wizards (Vol. 1)</p></a> <a href="/posts/AI-Detector-Humanizer/" class="btn btn-outline-primary" prompt="下一篇"><p>AI Detector & Humanizer | Vincent's Technical Reports (Vol. 4)</p></a></div></div></div></div><div id="search-result-wrapper" class="d-flex justify-content-center unloaded"><div class="col-12 col-sm-11 post-content"><div id="search-hints"><div id="access-tags"><div class="panel-heading">热门标签</div><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/llm/">LLM</a> <a class="post-tag" href="/tags/network/">Network</a> <a class="post-tag" href="/tags/ai/">AI</a> <a class="post-tag" href="/tags/decompiler/">Decompiler</a> <a class="post-tag" href="/tags/detector/">Detector</a> <a class="post-tag" href="/tags/hello-world/">Hello World</a> <a class="post-tag" href="/tags/humanizer/">Humanizer</a> <a class="post-tag" href="/tags/number-theory/">Number Theory</a> <a class="post-tag" href="/tags/ocaml/">Ocaml</a> <a class="post-tag" href="/tags/programming-language/">Programming Language</a></div></div></div><div id="search-results" class="d-flex flex-wrap justify-content-center text-muted mt-3"></div></div></div></div><footer><div class="container pl-lg-4 pr-lg-4"><div class="d-flex justify-content-between align-items-center text-muted ml-md-3 mr-md-3"><div class="footer-left"><p class="mb-0"> © 2025 <a href="https://twitter.com/si57311">Vincent</a>. <span data-toggle="tooltip" data-placement="top" title="除非另有说明，本网站上的博客文章均由作者按照知识共享署名 4.0 国际 (CC BY 4.0) 许可协议进行授权。">保留部分权利。</span></p></div><div class="footer-right"><p class="mb-0">本站由 <a href="https://jekyllrb.com" target="_blank" rel="noopener">Jekyll</a> 生成，采用 <a href="https://github.com/cotes2020/jekyll-theme-chirpy" target="_blank" rel="noopener">Chirpy</a> 主题。</p></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/mermaid@8/dist/mermaid.min.js"></script> <script> (function () { function updateMermaid(event) { if (event.source === window && event.data && event.data.direction === ModeToggle.ID) { const mode = event.data.message; if (typeof mermaid === "undefined") { return; } let expectedTheme = (mode === ModeToggle.DARK_MODE ? "dark" : "default"); let config = {theme: expectedTheme}; /* Re-render the SVG › <https://github.com/mermaid-js/mermaid/issues/311#issuecomment-332557344> */ $(".mermaid").each(function () { let svgCode = $(this).prev().children().html(); $(this).removeAttr("data-processed"); $(this).html(svgCode); }); mermaid.initialize(config); mermaid.init(undefined, ".mermaid"); } } let initTheme = "default"; if ($("html[data-mode=dark]").length > 0 || ($("html[data-mode]").length == 0 && window.matchMedia("(prefers-color-scheme: dark)").matches)) { initTheme = "dark"; } let mermaidConf = { theme: initTheme /* <default|dark|forest|neutral> */ }; /* Create mermaid tag */ $("pre").has("code.language-mermaid").each(function () { let svgCode = $(this).children().html(); $(this).addClass("unloaded"); $(this).after(`<pre class=\"mermaid\">${svgCode}</pre>`); }); mermaid.initialize(mermaidConf); window.addEventListener("message", updateMermaid); })(); </script><div id="mask"></div><a id="back-to-top" href="#" aria-label="back-to-top" class="btn btn-lg btn-box-shadow" role="button"> <i class="fas fa-angle-up"></i> </a> <script src="https://cdn.jsdelivr.net/npm/simple-jekyll-search@1.10.0/dest/simple-jekyll-search.min.js"></script> <script> SimpleJekyllSearch({ searchInput: document.getElementById('search-input'), resultsContainer: document.getElementById('search-results'), json: '/assets/js/data/search.json', searchResultTemplate: '<div class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-lg-4 pr-lg-4 pl-xl-0 pr-xl-0"> <a href="{url}">{title}</a><div class="post-meta d-flex flex-column flex-sm-row text-muted mt-1 mb-1"> {categories} {tags}</div><p>{snippet}</p></div>', noResultsText: '<p class="mt-5">搜索结果为空</p>', templateMiddleware: function(prop, value, template) { if (prop === 'categories') { if (value === '') { return `${value}`; } else { return `<div class="mr-sm-4"><i class="far fa-folder fa-fw"></i>${value}</div>`; } } if (prop === 'tags') { if (value === '') { return `${value}`; } else { return `<div><i class="fa fa-tag fa-fw"></i>${value}</div>`; } } } }); </script> <script src="https://cdn.jsdelivr.net/combine/npm/magnific-popup@1/dist/jquery.magnific-popup.min.js,npm/lazysizes@5.3.2/lazysizes.min.js,npm/clipboard@2/dist/clipboard.min.js"></script> <script src="https://cdn.jsdelivr.net/combine/npm/dayjs@1/dayjs.min.js,npm/dayjs@1/locale/zh.min.js,npm/dayjs@1/plugin/relativeTime.min.js,npm/dayjs@1/plugin/localizedFormat.min.js"></script> <script defer src="/assets/js/dist/post.min.js"></script> <script> /* see: <https://docs.mathjax.org/en/latest/options/input/tex.html#tex-options> */ MathJax = { tex: { /* start/end delimiter pairs for in-line math */ inlineMath: [ ['$', '$'], ['\\(', '\\)'] ], /* start/end delimiter pairs for display math */ displayMath: [ ['$$', '$$'], ['\\[', '\\]'] ] } }; </script> <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script> <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js"></script> <script src="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/js/bootstrap.bundle.min.js"></script> <script defer src="/unregister.js"></script>
