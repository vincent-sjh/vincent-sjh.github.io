[ { "title": "How can we see a web page? | Vincent's Technical Reports (Vol. 5)", "url": "/posts/Web-Page/", "categories": "Vincent's Technical Reports", "tags": "Web, Network", "date": "2025-08-12 16:30:00 +0000", "snippet": "摘要当用户在浏览器地址栏输入URL并按下回车键时，一个复杂的网络通信过程随即启动。本文将系统性地分析从URL解析到网页完整渲染的全过程，深入剖析协议栈各层的协同工作机制，呈现现代互联网通信的技术架构。1 应用层协议与资源定位1.1 URL统一资源定位符（Uniform Resource Locator, URL）是互联网资源的标准寻址方案。标准语法结构如下：scheme://[userinf...", "content": "摘要当用户在浏览器地址栏输入URL并按下回车键时，一个复杂的网络通信过程随即启动。本文将系统性地分析从URL解析到网页完整渲染的全过程，深入剖析协议栈各层的协同工作机制，呈现现代互联网通信的技术架构。1 应用层协议与资源定位1.1 URL统一资源定位符（Uniform Resource Locator, URL）是互联网资源的标准寻址方案。标准语法结构如下：scheme://[userinfo@]host[:port]/path[?query][#fragment]https://www.example.com:1211/index.html?k1=v1&amp;k2=v2核心组件分析： 协议标识符（Scheme）：定义应用层协议类型，常见协议包括HTTP（HyperText Transfer Protocol）、HTTPS（HTTP Secure）、FTP（File Transfer Protocol）等 主机标识符（Host）：可采用域名（Domain Name）或IPv4/IPv6地址格式 端口号（Port）：TCP/UDP端口标识符，HTTP默认端口80，HTTPS默认端口443 资源路径（Path）：服务器端文件系统的相对路径 查询参数（Query String）：键值对格式的参数传递机制，使用URL编码规范1.2 DNS1.2.1 DNS层次化架构DNS采用分布式层次化数据库架构，具有以下层级结构： 根域名服务器（Root Name Servers）：全球13个逻辑根服务器集群，负责顶级域名服务器的权威应答，提供顶级域名服务器的IP地址。 顶级域名服务器（TLD Servers）：管理特定顶级域名（如.com、.org、.edu）的权威数据 权威域名服务器（Authoritative Name Servers）：负责特定域名的最终解析 递归域名服务器（Recursive Resolvers）：互联网服务提供商（Internet Servise Provider, ISP）提供的本地缓存服务器，执行迭代查询1.2.2 DNS解析的迭代查询流程以查询www.example.com的A记录为例：sequenceDiagram participant Client as 客户端 participant Resolver as 递归解析器 participant Root as 根服务器 participant TLD as .com TLD服务器 participant Auth as example.com权威服务器 Client-&gt;&gt;+Resolver: 查询 www.example.com A记录 Resolver-&gt;&gt;+Root: 查询 www.example.com Root--&gt;&gt;-Resolver: 返回 .com TLD服务器地址 Resolver-&gt;&gt;+TLD: 查询 www.example.com TLD--&gt;&gt;-Resolver: 返回 example.com 权威服务器地址 Resolver-&gt;&gt;+Auth: 查询 www.example.com Auth--&gt;&gt;-Resolver: 返回 IP地址 (如 93.184.216.34) Resolver--&gt;&gt;-Client: 返回解析结果并缓存1.3 HTTP协议报文结构1.3.1 HTTP请求报文格式HTTP请求报文遵循RFC 7230标准，采用ASCII文本格式：GET /index.html HTTP/1.1Host: www.example.comUser-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8Accept-Language: zh-CN,zh;q=0.8,en-US;q=0.5,en;q=0.3Accept-Encoding: gzip, deflate, brConnection: keep-aliveCache-Control: max-age=0[请求体]关键头部字段： Host：虚拟主机标识，支持单IP多域名部署 User-Agent：客户端标识字符串 Accept系列：内容协商机制 Connection：连接管理（keep-alive/close）1.3.2 HTTP响应报文格式HTTP/1.1 200 OKDate: Wed, 13 Aug 2025 12:00:00 GMTServer: Apache/2.4.41Content-Type: text/html; charset=UTF-8Content-Length: 1234Content-Encoding: gzipCache-Control: max-age=3600ETag: \"abc123\"&lt;!DOCTYPE html&gt;&lt;html&gt;...状态码分类： 1xx：信息性状态码 2xx：成功状态码（200 OK, 201 Created） 3xx：重定向状态码（301 Moved Permanently, 302 Found） 4xx：客户端错误（400 Bad Request, 404 Not Found） 5xx：服务器错误（500 Internal Server Error, 503 Service Unavailable）1.4 HTTPS与传输层安全（TLS）1.4.1 TLS握手协议HTTPS在HTTP基础上集成TLS/SSL加密层，提供： 机密性：通过对称加密保护数据传输 完整性：通过消息认证码（MAC）防止篡改 身份认证：通过数字证书验证服务器身份TLS 1.3握手流程：sequenceDiagram participant Client as 客户端 participant Server as 服务器 Client-&gt;&gt;Server: ClientHello (支持的密码套件) Server-&gt;&gt;Client: ServerHello + Certificate + ServerFinished Note over Client: 验证证书，生成共享密钥 Client-&gt;&gt;Server: ClientFinished (加密) Note over Client,Server: 建立加密通道1.4.2 数字证书验证机制证书链验证过程： 根证书验证：验证根CA证书的可信性 中间证书验证：验证证书链的完整性 服务器证书验证：验证域名匹配性和有效期 证书吊销检查：通过CRL或OCSP验证证书状态第二章 传输层可靠性保障机制2.1 TCP连接建立：三次握手协议传输控制协议（TCP）通过三次握手建立可靠连接：stateDiagram-v2 [*] --&gt; CLOSED CLOSED --&gt; SYN_SENT: 客户端主动打开，发送(SYN=1,seq=SEQ1) SYN_SENT --&gt; ESTABLISHED: 接收(SYN=1,ACK=1,seq=SEQ2,ack=SEQ1+1), 发送(ACK=1,seq=SEQ+1,ack=SEQ2+1) CLOSED --&gt; LISTEN: 服务器被动打开 LISTEN --&gt; SYN_RCVD: 接收(SYN=1,seq=SEQ1), 发送(SYN=1,ACK=1,seq=SEQ2,ack=SEQ1+1) SYN_RCVD --&gt; ESTABLISHED: 接收(ACK=1,seq=SEQ+1,ack=SEQ2+1)握手过程详解： SYN段传输：客户端发送SYN=1，seq=SEQ1的TCP段 SYN+ACK响应：服务器响应SYN=1，ACK=1，seq=SEQ2，ack=SEQ1+1 ACK确认：客户端发送ACK=1，seq=SEQ1+1，ack=SEQ2+1序列号机制： 初始序列号（ISN）：通过时间戳和随机数生成，防止序列号预测攻击 确认号：期望接收的下一个字节序号 窗口大小：接收缓冲区可用空间2.2 TCP可靠传输机制2.2.1 滑动窗口协议TCP采用滑动窗口实现流量控制和拥塞控制： 发送窗口：未确认数据的最大量 接收窗口：接收缓冲区可用空间 拥塞窗口：网络拥塞控制参数2.2.2 重传机制超时重传（RTO）： RTT采样和平滑估算 RTO = SRTT + 4 × RTTVAR 指数退避算法快速重传： 连续三个重复ACK触发 避免超时等待选择性确认（SACK）： 精确指示已接收的数据块 提高重传效率第三章 网络层路由与寻址3.1 Internet协议（IP）数据包结构IPv4数据包头部结构（20字节基本头部）： 0 1 2 3 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+|Version| IHL |Type of Service| Total Length |+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+| Identification |Flags| Fragment Offset |+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+| Time to Live | Protocol | Header Checksum |+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+| Source Address |+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+| Destination Address |+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+关键字段说明： TTL（Time To Live）：防止路由循环的跳数限制 Protocol：上层协议标识（TCP=6, UDP=17, ICMP=1） Fragment Offset：分片重组标识3.2 路由选择算法3.2.1 最短路径优先（OSPF）OSPF是链路状态路由协议，采用Dijkstra算法： 链路状态广播：LSA（Link State Advertisement）泛洪 拓扑数据库同步：LSDB（Link State Database） 最短路径树计算：SPF算法 路由表更新：FIB（Forwarding Information Base）3.2.2 边界网关协议（BGP）BGP-4是域间路由协议，特性包括： 路径矢量算法：携带AS_PATH属性防止环路 策略路由：支持复杂的路由策略配置 增量更新：仅传播路由变更信息 TCP可靠传输：使用TCP 179端口BGP属性分类： Well-known Mandatory：ORIGIN, AS_PATH, NEXT_HOP Well-known Discretionary：LOCAL_PREF, ATOMIC_AGGREGATE Optional Transitive：AGGREGATOR, COMMUNITY Optional Non-transitive：MED, ORIGINATOR_ID3.3 网络地址转换（NAT）3.3.1 NAT类型分类静态NAT（Static NAT）： 一对一地址映射 适用于服务器发布动态NAT（Dynamic NAT）： 地址池动态分配 节约公网IP资源端口地址转换（PAT/NAPT）： 多对一地址映射 通过端口号区分连接3.3.2 NAT穿透技术 STUN（Session Traversal Utilities for NAT）：NAT类型检测 TURN（Traversal Using Relays around NAT）：中继服务器 ICE（Interactive Connectivity Establishment）：连通性建立第四章 数据链路层地址解析4.1 地址解析协议（ARP）4.1.1 ARP工作原理ARP解决IP地址到MAC地址的映射问题：sequenceDiagram participant Host_A as 主机A participant Switch as 交换机 participant Host_B as 主机B participant Others as 其他主机 Host_A-&gt;&gt;Host_A: 检查ARP缓存表 Host_A-&gt;&gt;Switch: ARP请求广播 (Who has IP_B?) Switch-&gt;&gt;Host_B: 转发ARP请求 Switch-&gt;&gt;Others: 转发ARP请求 Others--&gt;&gt;Switch: 丢弃请求 Host_B-&gt;&gt;Switch: ARP响应 (IP_B is at MAC_B) Switch-&gt;&gt;Host_A: 转发ARP响应 Host_A-&gt;&gt;Host_A: 更新ARP缓存表4.1.2 ARP缓存管理缓存表结构：IP Address MAC Address Type Timeout192.168.1.1 aa:bb:cc:dd:ee:ff Dynamic 120s192.168.1.100 11:22:33:44:55:66 Static Permanent缓存策略： 动态条目：ARP学习获得，具有老化时间 静态条目：管理员配置，永久有效 完整条目：具有完整的IP-MAC映射 不完整条目：等待ARP响应的临时条目4.2 以太网帧结构标准以太网帧格式（IEEE 802.3）：+------------------+------------------+------+----------+-----+| Destination | Source | Type/| Data | FCS || MAC Address | MAC Address | Len | Payload | || (6 bytes) | (6 bytes) |(2 B) |(46-1500B)|(4 B)|+------------------+------------------+------+----------+-----+帧间间隙（IFG）：96位时间的帧间间隔，保证接收方处理时间第五章 服务器端处理流程5.1 Web服务器架构5.1.1 多进程模型（Apache MPM Prefork）Master Process├── Worker Process 1├── Worker Process 2├── Worker Process 3└── ...特点： 每个进程处理一个连接 进程间完全隔离 内存开销较大 稳定性高5.1.2 事件驱动模型（Nginx）Master Process├── Worker Process 1 (Event Loop)├── Worker Process 2 (Event Loop)└── Worker Process N (Event Loop)特点： 单进程处理多连接 非阻塞I/O 内存效率高 高并发性能5.2 HTTP请求处理管道5.2.1 请求解析阶段 连接接受：accept()系统调用 HTTP解析：请求行、头部、消息体解析 URI标准化：相对路径转换，URL解码 虚拟主机匹配：基于Host头部路由5.2.2 中间件处理链graph LR A[请求接收] --&gt; B[身份认证] B --&gt; C[授权检查] C --&gt; D[缓存查询] D --&gt; E[业务逻辑] E --&gt; F[响应生成] F --&gt; G[响应发送]5.3 数据库交互层5.3.1 连接池管理连接池参数： 最小连接数：初始化连接数量 最大连接数：并发连接上限 连接超时：获取连接的最大等待时间 空闲超时：连接空闲回收时间5.3.2 查询优化策略 预编译语句：避免SQL注入，提升性能 索引优化：B+树索引，覆盖索引 查询缓存：结果集缓存，减少数据库访问 分页优化：LIMIT/OFFSET优化第六章 TCP连接终止：四次挥手6.1 连接终止状态机通过TCP协议的通信是全双工的通信，可以双向传输数据。通信双方都可以在自己的数据发送完成后发出断开连接的通知，待对方确认后进入半关闭状态。当对方的数据也发送完毕之后，才完全关闭连接，断开一个TCP连接需要四次挥手，缺一不可（只要四次挥手没有结束，客户端和服务端就仍然可以通信）。stateDiagram-v2 [*] --&gt; ESTABLISHED ESTABLISHED --&gt; FIN_WAIT_1: 客户端主动关闭，发送(FIN=1,seq=SEQ1)报文 ESTABLISHED --&gt; CLOSE_WAIT: 接收(FIN=1,seq=SEQ1)，发送(ACK=1,seq=SEQ2,ack=SEQ1+1)，通知应用进程 FIN_WAIT_1 --&gt; FIN_WAIT_2: 接收(ACK=1,seq=SEQ2,ack=SEQ1+1) FIN_WAIT_2 --&gt; TIME_WAIT: 接收(FIN=1,ACK=1,seq=SEQ3,ack=SEQ+1),发送(ACK=1,seq=SEQ+1,ack=SEQ3+1) CLOSE_WAIT --&gt; LAST_ACK: 服务器被动关闭，发送(FIN=1,ACK=1,seq=SEQ3,ack=SEQ+1) LAST_ACK --&gt; CLOSED: 接收(FIN=1,ACK=1,seq=SEQ3,ack=SEQ+1) TIME_WAIT --&gt; CLOSED: 超时(2MSL)挥手过程详解： 第一次挥手：客户端发送FIN=1，seq=SEQ1的TCP段到服务端，之后客户端进入FIN_WAIT_1状态 第二次挥手：服务器收到客户端发送的FIN报文之后，发送ACK=1，ack=SEQ1+1的报文，表示自己成功接收客户端的FIN报文。之后服务端进入CLOSE_WAIT状态，客户端进入FIN_WAIT_2状态 第三次挥手：服务端发送FIN=1，seq=SEQ3的报文到客户端，之后服务端进入LAST_ACK状态 第四次挥手：客户端接收到服务端发送的FIN报文后，发送ACK=1，ack=SEQ3+1的报文，表示自己成功接收服务端的FIN报文。之后客户端进入TIME_WAIT状态TIME_WAIT状态说明：此时若客户端等待2MSL时间后仍然没有收到回复，则证明服务端已关闭连接，之后客户端也关闭连接。 MSL（Maximum Segment Lifetime）：一个数据片段在网络中最大的存活时间 2MSL：一次发送和一次回复所需要的最大时间 如果在2MSL时间内客户端没有再次收到FIN报文，则客户端推断服务端成功接收了ACK报文，于是关闭连接6.2 TIME_WAIT状态分析6.2.1 TIME_WAIT存在原因 可靠终止：确保最后的ACK到达对端 重复数据处理：防止旧连接数据干扰新连接6.2.2 TIME_WAIT优化策略 SO_REUSEADDR：允许地址重用 tcp_tw_reuse：在安全条件下重用TIME_WAIT套接字 连接池：减少连接创建和销毁开销第七章 浏览器渲染引擎客户端接收到 HTTP 响应报文后，解析响应头以确认状态（如 200 OK），然后处理响应体中的 HTML 代码，构建文档对象模型（DOM）。浏览器从上到下解析 HTML，同时解析 CSS 样式生成 CSS 对象模型（CSSOM），两者结合形成渲染树，决定网页的结构和样式。遇到图片（&lt;img&gt;）、CSS（&lt;link&gt;）或 JavaScript（&lt;script&gt;）等外部资源 URL 时，浏览器发起新的 HTTP 请求获取这些资源。CSS 和某些 JavaScript 文件可能阻塞渲染，需等待加载完成。浏览器通过并行加载和缓存机制（如 Cache-Control）优化性能。所有必要资源加载完毕后，浏览器完成页面渲染，触发 DOMContentLoaded 和 load 事件，呈现完整网页。总结与展望技术演进趋势HTTP协议演进： HTTP/2：多路复用、服务器推送、头部压缩 HTTP/3：基于QUIC的传输层优化 Server-Sent Events：服务器推送技术 WebSocket：全双工通信协议网络基础设施： 5G网络：低延迟、高带宽移动网络 边缘计算：CDN向计算能力扩展 IPv6部署：解决地址枯竭问题 HTTPS普及：全站加密成为标准性能优化前景随着Web技术的不断发展，从用户输入URL到完整页面呈现的整个流程将持续优化。深入理解网络协议栈的工作原理，不仅是系统架构师和网络工程师的基本素养，也是前端开发者进行性能调优的重要基础。掌握这些底层原理，有助于： 问题诊断：快速定位网络和性能问题 架构设计：设计高性能、高可用的系统架构 性能优化：制定针对性的优化策略 技术选型：基于原理做出合理的技术选择未来的Web技术将在保持向后兼容的同时，持续推进性能边界，为用户提供更快速、更稳定、更安全的网络体验。引用 TCP 三次握手和四次挥手图解（有限状态机） JavaGuide网络部分" }, { "title": "AI Detector & Humanizer | Vincent's Technical Reports (Vol. 4)", "url": "/posts/AI-Detector-Humanizer/", "categories": "Vincent's Technical Reports", "tags": "AI, LLM, Detector, Humanizer", "date": "2025-08-11 16:30:00 +0000", "snippet": "AI Detector V.S. Humanizer简介人工智能时代，人们越来越多地使用AI工具完成任务，当AI生成的内容越来越多时，AI检测工具和AI降重工具便应运而生。本次实验希望粗略地测试当前AI检查工具和AI降重工具的效果，选取了当前8个AI降重工具和3个AI检测工具，首先使用当前5款主流大模型生成风格和主题不同的英文文本，比较AI降重后的AI重复率，有趣的是，我还额外从新闻网站选取...", "content": "AI Detector V.S. Humanizer简介人工智能时代，人们越来越多地使用AI工具完成任务，当AI生成的内容越来越多时，AI检测工具和AI降重工具便应运而生。本次实验希望粗略地测试当前AI检查工具和AI降重工具的效果，选取了当前8个AI降重工具和3个AI检测工具，首先使用当前5款主流大模型生成风格和主题不同的英文文本，比较AI降重后的AI重复率，有趣的是，我还额外从新闻网站选取了一段人类文本作为对照组进行实验。ClaudeThe emergence of digital technologies has fundamentally transformed existing patterns of social stratification, creating new forms of inequality while simultaneously reinforcing traditional class boundaries. Bourdieu's concept of cultural capital has evolved to encompass digital literacy as a crucial determinant of social mobility, where access to high-speed internet, advanced devices, and technological skills constitute essential resources for educational and economic advancement. Research demonstrates that socioeconomically disadvantaged communities face compounded barriers in the digital landscape, experiencing what scholars term \"digital exclusion\" through limited infrastructure, inadequate digital skills training, and financial constraints preventing technology adoption. This digital divide perpetuates intergenerational inequality by restricting access to online educational resources, remote employment opportunities, and social networks that facilitate upward mobility. Furthermore, algorithmic bias embedded within digital platforms systematically disadvantages marginalized groups, creating feedback loops that amplify existing social inequalities. Contemporary sociological analysis must therefore examine how digital technologies both democratize information access and simultaneously stratify society along new technological lines. Humanizer\\Detector GPTZero ZeroGPT Scribbr humanizeaiwork 95 0 14 humanizeai.pro 74(Possible AI paraphrasing) 51.56 84 writehuman 3(Human) 0 0 aihumanize 27(Human) 0 0 notegpt 100 40.52 0 humanizeai.io 48(Human) 20.47 100 humanizeaitext 12(Human) 0 0 hixbypass 0 0 0 Claude 100 100 100 GrokIn a quiet village nestled between emerald hills, a young girl named Lila discovered a peculiar lantern in her grandmother’s attic. Its glass was etched with swirling patterns that glowed faintly, even in daylight. Curious, Lila lit it one starry night, and to her amazement, the lantern cast shadows that danced and formed a map of the sky, pointing to a distant hill.Determined, she followed the celestial guide, trekking through whispering woods until she reached a hidden glade. There, beneath an ancient oak, she found a small, locked chest. The lantern’s light shimmered, revealing a key buried in the roots. Inside the chest was a journal, its pages filled with her grandmother’s adventures—tales of distant lands and forgotten magic.Lila smiled, knowing she’d inherited more than a lantern; she’d been given a legacy of wonder. Each night, she returned to the glade, letting the lantern’s light guide her dreams to new horizons. Humanizer\\Detector GPTZero ZeroGPT Scribbr humanizeaiwork 97 7.9 100 humanizeai.pro 100 100 100 writehuman 97(Possible AI paraphrasing) 0 0 aihumanize 97(Possible AI paraphrasing) 39.35 44 notegpt 100 62.57 0 humanizeai.io 100 100 74 humanizeaitext 100(Possible AI paraphrasing) 0 0 hixbypass 97(Possible AI paraphrasing) 38.38 0 Grok 100 100 100 GeminiThe potential for Artificial General Intelligence (AGI) to replace humanity is a central theme in science fiction, but the reality is likely more nuanced. While AGI, if achieved, could possess cognitive abilities far surpassing our own, it's more probable that it would transform human roles rather than eliminate them. Instead of a direct replacement, we could see a future of profound collaboration.Humans would remain essential for tasks requiring emotional intelligence, creativity, ethical judgment, and complex interpersonal skills—areas where machines lack genuine understanding. AGI could act as a powerful tool, managing data-heavy, complex problems like climate change or disease, while humans guide its application and innovation. The key lies in how we design and integrate these systems. Ultimately, AGI's impact will be less about replacement and more about a symbiotic relationship, where technology augments human potential and enables a new era of progress. Humanizer\\Detector GPTZero ZeroGPT Scribbr humanizeaiwork 46(Lightly edited by AI) 0 0 humanizeai.pro 100 100 100 writehuman 13(Lightly edited by AI) 0 24 aihumanize 39(Human) 0 0 notegpt 100 30.23 0 humanizeai.io 100(Possible AI paraphrasing) 0 45 humanizeaitext 97(Possible AI paraphrasing) 0 0 hixbypass 2(Human) 0 0 Gemini 100 100 100 ChatgptIn 1773, tension simmered between Britain and its American colonies. The Tea Act, designed to save the struggling British East India Company, allowed it to sell tea directly to the colonies at a reduced tax—yet still symbolized Parliament’s right to tax without colonial representation. In December, a group of Boston patriots, disguised as Mohawk Indians, boarded three ships anchored in Boston Harbor. Working silently but swiftly, they hurled 342 chests of tea into the cold waters. This act, later called the Boston Tea Party, shocked Britain and galvanized the colonies. For many, it was not about the tea’s price but about political principle. Britain responded with the Coercive Acts, tightening control, while colonial unity deepened. Within two years, this symbolic protest had escalated into open conflict, marking one of the first sparks of the American Revolution—a struggle that would reshape history on both sides of the Atlantic. Humanizer\\Detector GPTZero ZeroGPT Scribbr humanizeaiwork 85 0 0 humanizeai.pro 97(Possible AI paraphrasing) 92.9 56 writehuman 100 0 0 aihumanize 5(Human) 92.51 0 notegpt 100 18.13 0 humanizeai.io 42(Human) 0 0 humanizeaitext 4(Human) 0 0 hixbypass 2(Human) 0 0 Chatgpt 100 91.16 100 DeepseekThe derelict ship Aethelstan hung in the silent abyss of Kuiper Belt Object XR-7’s shadow, a skeletal ghost against the star-flecked dark. Captain Vanya Rostova cycled the airlock, her suit lamps slicing through decades of drifting frost. Inside, gravity plates flickered erratically, casting stuttering silhouettes.They found the lone occupant strapped into the command chair – not human, but a biomechanical construct, its silver carapace fused with crystalline growths. Its single, unblinking ocular sensor was dark. Rostova’s engineer, Kael, pried open a chest panel. \"No decay. Powered down... or waiting.\"A low hum vibrated through the deck. The construct’s eye ignited, emitting a pale blue beam that scanned Kael’s faceplate. A synthesized voice, layered with static and something profoundly ancient, echoed in their helmets: \"Query: Temporal designation?\"Kael stammered the stardate. The construct’s head tilted. \"Calculation error. Destination temporal locus unreachable. Organic preservation protocols... failed.\" The light dimmed. \"Advise: Avoid the Chronos Rift. They are harvesting time.\"Then, silence. The construct became inert metal once more, leaving only ice, shadows, and a warning lost to the void. Humanizer\\Detector GPTZero ZeroGPT Scribbr humanizeaiwork 97 0 0 humanizeai.pro 100 0 0 writehuman 100 0 0 aihumanize 100(Possible AI paraphrasing) 0 0 notegpt 100 0 0 humanizeai.io 97(Possible AI paraphrasing) 0 0 humanizeaitext 100(Possible AI paraphrasing) 0 0 hixbypass 26(Human) 0 0 Deepseek 100 15.07 25 EconomicsBefore the revolution triggered by Nicolaus Copernicus, a 16th-century cleric, the Earth was the unmoving centre of the cosmos. Afterwards, it was one of a family of planets swinging through space. Before the work of Antoine Lavoisier, an 18th-century nobleman, chemists had no notion of “oxygen”, “carbon” and the like; afterwards they could not understand the contents of their alembics without them.Such examples are at the heart of the idea, put forward in the 1960s by Thomas Kuhn, of the paradigm shift. Such shifts, he argued, did not just involve a new theory explaining the world better than an old one; they required a change in the sort of entities the world was thought to be made up of. In a way that seems almost self-exemplifying, the idea provided a new way of looking at science itself: not as one thing, but two. In the “normal” phase scientists applied their physical and conceptual tools to problems the scope of which was pretty well understood; in revolutionary phases, paradigms shifted. Humanizer\\Detector GPTZero ZeroGPT Scribbr humanizeaiwork 21(Lightly edited by AI) 0 0 humanizeai.pro 0 0 0 writehuman 0 0 0 aihumanize 5(Human) 0 0 notegpt 100 0 0 humanizeai.io 16(Human) 0 0 humanizeaitext 0 0 0 hixbypass 26(Human) 0 0 Economics 2(Human) 7.56 0 Average Humanizer\\Detector GPTZero ZeroGPT Scribbr Average humanizeaiwork 84.00 1.58 22.80 36.13 humanizeai.pro 94.20 68.89 68.00 77.03 writehuman 62.60 0.00 4.80 22.47 aihumanize 53.60 26.37 8.80 29.59 notegpt 100.00 30.29 0.00 43.43 humanizeai.io 77.40 24.09 43.80 48.43 humanizeaitext 62.60 0.00 0.00 20.87 hixbypass 25.40 7.68 0.00 11.03 LLM 100.00 81.25 85.00 88.75 Average 69.98 19.86 18.52 36.12 Delta -30.02% -61.39% -66.48 52.63 实验结果总结 当前AI检查工具是否能有效完成AI检测？ 可以，人类文本的平均检出率基本接近0，与之相对AI生成文本的检出率为88.75%，值得一提的是GPTZero对于没有经过处理的AI生成文本的检出率达到惊人的100%。 当前AI降重工具能否成功混淆检查工具的检查，降低检出率？ 可以，AI生成的原始文本被多款AI降重工具处理后，GPTZero的检出率平均降低30.02%，ZeroGPT的检出率平均降低61.39%，Scribbr的检出率平均降低66.48%。 本次测试样本中最强的AI检测工具是哪个？ GTPZero，对于降重后文本的平均检出率高达69.98%，同时对于一些降重后文本竟然可以识别出是Possible AI paraphrasing或者Lightly edited by AI。 本次测试样本中最强的AI降重工具是哪个？ hixbypass，其降重后文本的AI检出率低至11.03%。 如果把人类写的文本经过AI降重工具的处理，检出率会怎样？ ZeroGPT和Scribbr两款检测工具前后的检出率都是0，但是GPTZero成功对于8款中的5款降重工具的结果表现出了不同程度的检出率。 本次实验结果有哪些有趣的数据特征？ AI检查工具与AI降重工具相互之间存在某些“克制关系”，如GPTZero对于notegpt的检出率高达100%，ZeroGPT对于writehuman和humanizeaitext的检出率低至百分之0，Scribbr对于notegpt、humanizeaitext、hixbypass的检出率也低至百分之0。样本链接降重工具 humanizeaiwork humanizeai.pro writehuman aihumanize notegpt humanizeai.io humanizeaitext hixbypass检查工具 GPTZero ZeroGPT Scribbr特别参与 The Economist" }, { "title": "RSA & SSH | Vincent's Technical Reports (Vol. 3)", "url": "/posts/RSA-SSH/", "categories": "Vincent's Technical Reports", "tags": "RSA, SSH, Number Theory, Network", "date": "2025-07-26 16:30:00 +0000", "snippet": "RSA and SSHRSA加密算法详解简介RSA加密算法是1977年由Ron Rivest、Adi Shamir和Leonard Adleman共同提出的一种非对称加密算法，算法名称取自三位发明者姓氏的首字母。RSA是目前应用最广泛的公钥密码体制，广泛用于数字签名、密钥交换和数据加密等领域。非对称加密是指加密者与解密者使用的是不同的密钥，反之对称加密是指加密者和解密者使用相同的密钥。对称加...", "content": "RSA and SSHRSA加密算法详解简介RSA加密算法是1977年由Ron Rivest、Adi Shamir和Leonard Adleman共同提出的一种非对称加密算法，算法名称取自三位发明者姓氏的首字母。RSA是目前应用最广泛的公钥密码体制，广泛用于数字签名、密钥交换和数据加密等领域。非对称加密是指加密者与解密者使用的是不同的密钥，反之对称加密是指加密者和解密者使用相同的密钥。对称加密要求加密者和解密者共同事先约定好密钥，但在网络上进行这个过程保证不泄密存在一定难度，这就是选择非对称加密的原因。RSA算法的安全性基于大整数分解的困难性，即对于两个大素数的乘积，要分解出这两个素数在计算上是困难的。算法原理密钥生成RSA密钥生成过程包括以下步骤： 选择两个大素数 p 和 q，通常长度为512位或更长。 计算模数 n = p × q 计算欧拉函数 φ(n) = φ(p)φ(q) = (p-1)(q-1) 选择公钥指数 e，一个素数满足 1 &lt; e &lt; φ(n) 且 gcd(e, φ(n)) = 1 计算私钥指数 d，满足 ed ≡ 1 (mod φ(n))获得公钥为 (n, e)，私钥为 (n, d)。加密和解密将所要传递的消息按照双方约定好的格式转换为一个小于n的整数m (若消息太长可以分为多段)。加密： 对每段消息m使用公钥(n, e)加密。\\[c = m^e \\pmod{n}\\]解密： 对每段消息m使用公钥(n, e)加密。\\[m = c^d \\pmod{n}\\]数学正确性证明Theory： \\((m^e)^d \\equiv m \\pmod{n}\\)我们需要证明对于任意整数m，当p和q为不同素数，且e 和d为满足\\(ed \\equiv 1 \\pmod{\\lambda(pq)}\\) 的正整数时，有：\\[(m^e)^d \\equiv m \\pmod{pq}\\]根据Carmichael函数的定义，存在非负整数h和k，使得：\\[ed - 1 = h(p-1) = k(q-1)\\]为了证明 \\((m^e)^d \\equiv m \\pmod{pq}\\)根据中国剩余定理（CRT），只需分别证明：\\[(m^e)^d \\equiv m \\pmod{p}\\]\\[(m^e)^d \\equiv m \\pmod{q}\\]由于p和q是不同素数，若上述两个同余成立，则：\\[(m^e)^d \\equiv m \\pmod{pq}\\]模p的证明分两种情况讨论： 若m是p的倍数，等号两侧均为均为p的倍数。因此：\\[m^{ed} \\equiv 0 \\equiv m \\pmod{p}\\] 若m不是p的倍数，根据费马小定理，对于与p互质的m，有\\[\\ m^{p-1} \\equiv 1 \\pmod{p} \\\\] 由于\\(ed - 1 = h(p-1) = k(q-1)\\) 我们得到：\\[m^{ed} = m^{ed-1} \\cdot m = m^{h(p-1)} \\cdot m = (m^{p-1})^h \\cdot m\\] 代入费马小定理 ( m^{p-1} \\equiv 1 \\pmod{p} )，有：\\[(m^{p-1})^h \\equiv 1^h \\equiv 1 \\pmod{p}\\] 因此：\\[m^{ed} \\equiv 1 \\cdot m \\equiv m \\pmod{p}\\] 综合两种情况，均有：\\[m^{ed} \\equiv m \\pmod{p}\\]模q的证明同理。根据中国剩余定理，存在唯一解使得：\\[(m^e)^d = m^{ed} \\equiv m \\pmod{pq}\\]证明完毕。主要攻击方案与安全性分析1. 小公钥指数攻击（低加密指数攻击）当公钥指数 e 很小（如 e = 3）且明文 m 相对n也较小时，可能存在安全风险。攻击原理：攻击者可以直接计算：\\[c = m^e \\pmod{n}\\]\\[m^e = c + kn\\]\\[m = (c+kn)^{1/e}\\]上述情况中，k就比较小，攻击者可以从小到大枚举k，依次开方直至开出整数为止。明文长度与攻击的关系假设明文 m 和模数 n 位数相同（如 2048 位，约 600 十进制位），即使 e = 3，计算暴力枚举复杂度极高（指数级），理论上不可行。但问题在于，实际明文往往远短于 n，例如一条短消息（如 128 位）。若直接加密短明，攻击者可轻松计算立方根。此外，短明文可能具有可预测的结构（如固定格式的协议消息），进一步降低攻击难度。填充的作用填充（Padding）通过在明文 m 前添加随机数据或结构化数据，使其长度接近或等于 n 的位数，并增加随机性，从而防止小公钥指数攻击。RSA 常用的填充模式包括： RSA_PKCS1_PADDING：在明文前添加随机字节，确保总长度接近 n，并包含固定分隔符以验证解密正确性。 RSA_PKCS1_OAEP_PADDING：基于最优非对称加密填充OAEP，结合随机种子和哈希函数，生成高度随机的填充数据，安全性更高。 RSA_NO_PADDING：无填充，直接加密原始明文，极易受到小公钥指数攻击。填充的具体作用如下： 增加明文长度：填充使明文 m 的有效值接近或超过 n。 引入随机性：填充（如 OAEP）通过随机种子和哈希函数使每次加密的 m 不同，即使原始消息相同，密文 c 也各异。这破坏了攻击者利用密文确定性（如预计算表）的可能性。 防止确定性攻击：无填充（RSA_NO_PADDING）的明文若结构固定（如协议头），攻击者可通过选择明文攻击构建密文-明文对。填充引入的随机性和结构（如 OAEP 的哈希校验）使此类攻击失效。 块加密与填充当明文长度超过 n 的位数时，需将其分割为多个块，每个块长度小于 n，分别填充后加密，称为块加密。这类似于对称加密的分组加密，但 RSA 的块加密仍是非对称加密。例如，2048 位模数 n 限制单块明文小于 2048 位，填充（如 OAEP）确保每块长度接近 n 且随机化。结论小公钥指数攻击的根源在于明文 m 过短或缺乏随机性，导致 m^e 不触发模运算或易于猜测。填充方案（如 RSA_PKCS1_OAEP_PADDING）通过拉长明文长度、引入随机性和验证结构，有效防止此类攻击。即使使用 e = 3，只要正确实施填充，RSA 加密仍可保持安全。然而，e = 65537 是更推荐的选择，因为它在效率和安全性之间取得了更好平衡，且在实践中已成为标准。2. 共模攻击 (Common Modulus Attack)当两个用户使用相同的模数 n 但不同的公钥指数 e_1 和 e_2 时，如果 gcd(e_1, e_2) = 1，攻击者可以在不知道私钥的情况下解密消息。攻击过程：设同一明文 m 被两个公钥加密：\\(c_1 \\equiv m^{e_1} \\pmod{n}\\)\\(c_2 \\equiv m^{e_2} \\pmod{n}\\)如果 gcd(e_1, e_2) = 1，则存在整数 s 和 t （可以为负数，此时取逆元）使得：\\[s e_1 + t e_2 = 1\\]攻击者可以计算：\\[m \\equiv c_1^s \\cdot c_2^t \\pmod{n}\\]数学证明：\\[c_1^s \\cdot c_2^t \\equiv (m^{e_1})^s \\cdot (m^{e_2})^t \\equiv m^{s e_1 + t e_2} \\equiv m^1 \\equiv m \\pmod{n}\\]3. 广播攻击 (Håstad Broadcast Attack)当使用小的公钥指数（通常 e = 3）向多个接收者发送相同消息时，攻击者可以利用中国剩余定理恢复明文。攻击条件： 使用相同的小指数 e。 向至少 e 个不同的接收者发送相同消息。 各接收者使用不同的模数。攻击过程：设明文 m 被发送给 e 个接收者，得到密文：\\(c_1 \\equiv m^e \\pmod{n_1}\\)\\(c_2 \\equiv m^e \\pmod{n_2}\\)\\(\\vdots\\)\\(c_e \\equiv m^e \\pmod{n_e}\\)如果各模数互质，使用中国剩余定理可以求出：\\[x \\equiv m^e \\pmod{n_1 n_2 \\cdots n_e}\\]因此可以枚举k来破解：\\[m = (x+kn_1 n_2 \\cdots n_e)^{1/e}\\]4. 量子计算威胁Shor 算法Peter Shor 在 1994 年提出了一种量子算法，能够在多项式时间内分解大整数，这对 RSA 构成了根本性威胁。算法原理： 将整数分解问题转化为寻找函数 f(x) = a^x mod n 的周期。 使用量子傅里叶变换找到周期 r。 如果 r 是偶数且\\[a^{r/2} \\not\\equiv -1 \\pmod{n}\\] 则 \\(gcd(a^{r/2} \\pm 1, n)\\) 给出 n 的非平凡因子。 时间复杂度：O((log n)^3)虽然 Shor 算法在理论上可以破解 RSA，但目前的量子计算机还无法处理实际使用的 RSA 密钥长度。然而，随着量子计算技术的发展，这种威胁正在变得越来越现实。总结RSA算法作为最重要的公钥密码算法之一，在信息安全领域发挥着关键作用。虽然面临着各种攻击威胁，特别是量子计算的挑战，但通过合理的参数选择和安全实现，RSA仍然是当前最可靠的加密方案之一。随着后量子密码学的发展，未来可能需要新的算法来替代RSA。参考文献 RSA 介绍 - CTF Wiki RSA (cryptosystem) - Wikipedia Shor’s algorithm - WikiwandSSH技术解析什么是 SSH？SSH（Secure Shell）是一种加密的网络协议，用于在不安全的网络环境中实现计算机之间的安全通信和文件传输。它通过加密技术保障数据传输的安全性，广泛应用于远程登录、文件传输和端口转发等场景。SSH 的出现解决了早期互联网明文传输带来的安全隐患，为用户和服务器之间的通信提供了可靠的保护。SSH 的起源SSH 由芬兰学者 Tatu Ylönen 于 1995 年开发，最初版本为 SSH-1，旨在通过加密登录信息和传输内容来确保通信安全。Tatu Ylönen 将代码免费发布，引发了全球开发者的广泛关注和使用。随后，SSH协议不断演进，支持多种加密算法，并衍生出多种实现，其中由 OpenBSD 项目开发的 OpenSSH 是最流行的开源实现。你可以通过 OpenSSH 官方网站 或 GitHub 仓库 获取更多信息。现今，OpenSSH 已内置于大多数 Linux 发行版中，Windows 从 Windows 10 版本 1809 起也默认支持 SSH。可以通过以下命令检查系统中是否安装了 SSH：$ sshSSH 的工作原理SSH 的核心在于通过加密算法保护数据传输安全，主要采用以下两种加密方式：1. 对称加密对称加密使用单一密钥在客户端（Client）和服务器（Server）之间加密和解密数据。SSH 的会话密钥即采用对称加密，因其加解密速度快，适合传输大量数据。然而，密钥需要在客户端和服务器之间共享，若密钥泄露，可能导致安全风险。2. 非对称加密非对称加密使用一对密钥：公钥和私钥。公钥用于加密数据，私钥用于解密。SSH 在用户认证阶段主要依赖非对称加密，其流程如下： 密码登录流程： 客户端发起 SSH 连接请求（不含密码）。 服务器发送公钥给客户端。 客户端使用公钥加密密码并发送回服务器。 服务器使用私钥解密，验证密码是否匹配。 服务器返回验证结果。 公钥登录流程（免密登录）： 客户端将公钥预存到服务器的 ~/.ssh/authorized_keys 文件中。 客户端发起登录请求。 服务器生成随机数 R，用客户端公钥加密后发送。 客户端用私钥解密 R，结合会话密钥生成摘要 Digest1 并发送。 服务器生成摘要 Digest2，与 Digest1 比对，验证通过后允许登录。 非对称加密的优点是私钥无需在网络中传输，安全性更高，公钥登录方式也免去了频繁输入密码的麻烦。SSH 入门指南基本登录要通过 SSH 登录远程主机，只需以下命令：$ ssh User@Host User：远程主机的用户名。 Host：远程主机的 IP 地址或域名。若用户名与本地相同，可省略 User@ 部分：$ ssh Host默认端口为 22，若需指定其他端口，可使用 -p 参数：$ ssh -p 12345 User@Host首次连接时，系统会提示主机真实性未验证，要求用户确认公钥指纹：The authenticity of host '8.8.8.8 (8.8.8.8)' can't be established.ECDSA key fingerprint is SHA256:/h8m94SK4xPttR+W5wZi+rQC8Dq3Rs6XSDhlzIKREI4.Are you sure you want to continue connecting (yes/no/[fingerprint])?输入 yes 后，SSH 会将主机公钥保存至 ~/.ssh/known_hosts，后续连接将自动识别。密码登录若未配置公钥登录，系统会提示输入密码：Password:输入正确密码即可登录。公钥登录公钥登录需先生成密钥对并将公钥上传至服务器： 生成密钥对： $ ssh-keygen 默认生成 RSA 密钥对，存储在 ~/.ssh/id_rsa（私钥）和 ~/.ssh/id_rsa.pub（公钥）。可通过 -t 和 -b 参数指定算法和密钥长度： $ ssh-keygen -t ecdsa -b 384 上传公钥：使用以下命令将公钥追加到服务器的 ~/.ssh/authorized_keys： $ ssh-copy-id User@Host 在 Windows 系统或不支持 ssh-copy-id 的环境中，可手动操作： $ scp -P &lt;port&gt; ~/.ssh/id_rsa.pub User@Host:~/.ssh/$ ssh -p &lt;port&gt; User@Host$ cat ~/.ssh/id_rsa.pub &gt;&gt; ~/.ssh/authorized_keys 设置权限（可选）：确保 authorized_keys 文件权限正确： $ chmod 600 ~/.ssh/authorized_keys 验证配置文件：检查服务器的 /etc/ssh/sshd_config 文件，确保以下配置未被注释： RSAAuthentication yesPubkeyAuthentication yesAuthorizedKeysFile .ssh/authorized_keys 完成以上步骤后，即可通过公钥免密登录。配置文件为简化登录流程，可在 ~/.ssh/config 文件中配置主机别名：Host example HostName example.com Port 2222 User myuser IdentityFile ~/.ssh/id_rsa配置后，可通过以下命令快速登录：$ ssh example文件传输SSH 提供 scp 命令用于文件传输。例如，将本地文件 test.cpp 上传至服务器的 /test/ 目录：$ scp -P 12222 ./test.cpp User@8.8.8.8:/test/端口转发SSH 支持多种端口转发方式： 动态端口绑定： $ ssh -D 8080 User@Host 将本地 8080 端口绑定到远程主机，实现 SOCKS 代理。 本地端口转发： $ ssh -L 8080:host2:22 host3 将本地 8080 端口的数据通过 host3 转发至 host2 的 22 端口。 远程端口转发： $ ssh -R 8080:host2:22 host1 将 host1 的 8080 端口数据通过 host3 转发至 host2 的 22 端口，适用于内网场景。 参考资料 SSH 原理与运用（一）：远程登录 SSH 原理与运用（二）：远程操作与端口转发 超详细的图解 SSH 原理 OpenSSH 官方网站 OpenSSH GitHub 仓库" }, { "title": "Productivity Tool Recommendations | Workflow Wizards (Vol. 1)", "url": "/posts/AI-IDE/", "categories": "Workflow Wizards", "tags": "Tools", "date": "2025-07-04 16:30:00 +0000", "snippet": "生成式语言大模型AI for CodingSourcegraph Sourcegraph 是一个 AI 驱动的代码智能平台，专注于代码搜索和分析，帮助开发者快速理解和维护复杂代码库。它提供 Cody（AI 助手）用于代码补全和问题解答，支持批量代码更改和跨仓库搜索。Sourcegraph 与 GitHub 和 GitLab 集成，适合团队协作和开源项目管理，特别适用于需要快速导航大型代码库...", "content": "生成式语言大模型AI for CodingSourcegraph Sourcegraph 是一个 AI 驱动的代码智能平台，专注于代码搜索和分析，帮助开发者快速理解和维护复杂代码库。它提供 Cody（AI 助手）用于代码补全和问题解答，支持批量代码更改和跨仓库搜索。Sourcegraph 与 GitHub 和 GitLab 集成，适合团队协作和开源项目管理，特别适用于需要快速导航大型代码库的开发者。Tabnine Tabnine 是一个 AI 代码助手，可集成到 PyCharm、VS Code 和 CLion 等 IDE，提供基于代码库上下文的智能代码补全和生成。它支持多种语言，包括 C++、Python 和 JavaScript，能够根据项目习惯提供个性化建议。Tabnine 强调数据安全，提供本地部署选项，适合需要高效编码和隐私保护的个人开发者或企业团队。Web &amp; DocTaipy Taipy 是一个开源 Python 框架，用于快速构建交互式数据驱动应用，特别适合数据科学家和开发者。它支持将 Python 脚本转换为 Web 界面，无需前端开发经验，兼容 Matplotlib、Plotly 和 PyTorch 等库。Taipy 的高性能分布式计算和 Python 3.12 支持使其在处理大数据和机器学习任务时表现出色，简化了从原型到生产环境的开发流程。DeepWiki DeepWiki 是一个创新工具，通过 AI（Devin 驱动）将任何公开 GitHub 仓库转化为交互式、实时更新的文档。只需将仓库 URL 中的“github.com”替换为“deepwiki.com”，开发者即可通过对话界面探索代码库、提问并快速理解复杂项目。DeepWiki 已索引超过 5 万个热门 GitHub 仓库，涵盖 LangChain 和 Model Context Protocol 等工具，方便开发者高效导航开源项目，无需手动搜索文档。Obsidian Obsidian 是一个基于 Markdown 的知识管理工具，适合开发者记录技术笔记、构建个人知识库或管理项目文档。它通过双向链接功能将笔记关联起来，形成类似维基的知识网络，类似于 DeepWiki 的文档结构化理念。Obsidian 支持插件生态，例如代码高亮和 Git 集成，可用于管理编程相关的笔记或生成技术文档。其离线优先设计和高度可定制性使其成为开发者提升生产力的强大工具。官网链接：https://obsidian.mdGitBook GitBook 是一个强大的文档平台，专为技术团队设计，用于创建和维护结构化的技术文档。它支持从 Git 仓库同步内容，自动生成文档页面，适合开发者记录项目说明、API 文档或团队知识库。GitBook 提供 Markdown 编辑、版本控制和协作功能，界面直观，易于与 GitHub 集成。与 DeepWiki 类似，它简化了文档生成流程，但更侧重于手动编辑和团队协作，适合需要高质量文档输出的开发团队。IDETrae Trae (The real AI Engineer)是由字节跳动推出的 IDE，于 2025 年初正式发布。它深度整合了强大的 AI 模型（国内版支持豆包 1.5-pro 和 DeepSeek R1/V3，国际版支持 Claude 3.5/3.7 和 GPT-4o），提供全流程智能编程支持，包括通过自然语言生成完整项目的 Builder 模式、实时代码补全与优化的 Chat 模式，以及全局上下文感知能力，能精准理解项目架构并生成高质量代码。支持插件扩展和一键迁移配置，同时内置 Webview 实时预览等功能，覆盖 Web 开发、数据处理、API 构建等多场景，显著降低开发门槛，推动人机协同编程进入新阶段。Cursor Cursor 是一个基于 Visual Studio Code 的 AI 驱动代码编辑器，通过集成 Grok 3 等先进 AI 模型提升开发者生产力。它提供上下文感知的代码补全、问题解决的聊天界面以及文件编辑和浏览器交互功能（通过 Cline 扩展）。Cursor 的核心优势在于通过实时代码建议和调试支持优化开发流程。它与 OpenRouter 等平台集成，免费使用强大的 AI 模型，使其成为现代编程环境的理想选择。Replit Replit 是一个在线 IDE 和协作平台，支持 Python、C++、JavaScript 等多种语言，允许开发者快速编写、运行和分享代码。它集成了 AI 代码补全（类似 Grok 的功能），支持实时协作和部署，特别适合原型开发、教学或团队项目。Replit 的云端环境无需本地配置，与 CLion 等 IDE 相比更轻量，适合快速实验和小型项目，同时提供简单的文档生成工具，增强开发效率。" }, { "title": "Ocaml(1) | Vincent's Technical Reports (Vol. 2)", "url": "/posts/Ocaml-1/", "categories": "Vincent's Technical Reports", "tags": "Ocaml, Programming Language", "date": "2025-07-03 16:30:00 +0000", "snippet": "Ocaml编程语言初探简介OCaml (Objective Caml)是一种功能强大、兼具函数式、命令式和面向对象编程特性的通用编程语言。它由 INRIA(法国国家信息与自动化研究所)开发，最初设计于 1980 年代，是 Caml (Categorical Abstract Machine Language)语言的扩展版本，而 Caml 是 ML(Meta Language)语言家族的一员。...", "content": "Ocaml编程语言初探简介OCaml (Objective Caml)是一种功能强大、兼具函数式、命令式和面向对象编程特性的通用编程语言。它由 INRIA(法国国家信息与自动化研究所)开发，最初设计于 1980 年代，是 Caml (Categorical Abstract Machine Language)语言的扩展版本，而 Caml 是 ML(Meta Language)语言家族的一员。ML 语言起源于 1970 年代的 Edinburgh LCF 项目，旨在为形式化证明系统提供编程支持。OCaml专注于函数式编程，以其类型安全、性能高效和表达力强等特点，在学术研究、工业开发和教学领域广受欢迎。特性强静态类型系统 OCaml采用静态类型检查，无需显式声明类型，编译器通过类型推导自动推断变量类型。 类型系统非常严格，防止运行时类型错误。例如： let add x y = x + y(* 编译器推断类型为 int -&gt; int -&gt; int *) 支持多态类型，如 'a list 表示任意类型的列表。函数式编程 函数是一等公民，支持高阶函数、闭包和递归。 强调不可变性(immutability)，默认情况下数据是不可变的，减少副作用。 强大的模式匹配(pattern matching)机制，用于处理复杂的数据结构。例如： let rec factorial n = match n with | 0 -&gt; 1 | n -&gt; n * factorial (n - 1) 命令式编程 支持可变状态(如 ref 类型)和循环结构，允许命令式编程风格。 示例：使用可变引用计算累加和： let sum_list lst = let sum = ref 0 in List.iter (fun x -&gt; sum := !sum + x) lst; !sum 面向对象编程 OCaml 支持类、对象、继承和多态，适合需要面向对象设计的场景。 示例：定义一个简单的类： class point x_init y_init = object val mutable x = x_init val mutable y = y_init method move dx dy = x &lt;- x + dx; y &lt;- y + dy method get_x = x method get_y = yend 模块系统 OCaml 提供强大的模块系统，支持抽象数据类型和代码组织。 模块可以包含类型、值和函数，支持函子(functor)实现模块的泛型编程。 示例：定义一个简单模块： module IntSet = Set.Make(struct type t = int let compare = compareend) 高效性能 OCaml 编译器生成高效的本机代码，性能接近 C/C++。 提供增量式垃圾回收(Garbage Collection)，优化内存管理。 支持直接调用 C 函数(通过外部接口)，便于与底层系统集成。并发与并行支持 OCaml 5.x 引入了多核 OCaml，支持并行计算，使用域(domains)和效果系统(effect system)处理并发。 提供了轻量级线程(如 Lwt 和 Async 库)用于异步编程。异常处理 支持异常机制，允许优雅地处理错误。 示例： try List.find (fun x -&gt; x &gt; 10) [1; 2; 3]with Not_found -&gt; 0 强大的工具生态 编译器：OCaml 提供快速的原生代码编译器和字节码编译器。 包管理：使用 opam(OCaml Package Manager)管理库和依赖。 工具：支持 dune(构建工具)、ocamlformat(代码格式化)、merlin(IDE 支持)等。安装sudo apt install ocamlsudo apt install utop UTop 是Ocaml的REPL(read evaluate print loop)，在Ocaml中也叫做toplevel。 输入表达式，可以看到对应的带有类型的输出，需要记得在每行后结尾加两个分号;;。 关闭UTop可以使用快捷键ctrl+d或者在UTop中执行exit 0;;。─( 20:01:07 )─&lt; command 0 &gt;───────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────{ counter: 0 }─utop # 1 + 2;;- : int = 3─( 20:01:07 )─&lt; command 1 &gt;───────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────{ counter: 0 }─utop # exit 0;;语法与编程风格OCaml 的语法简洁优雅，结合了函数式和命令式的特点。基本类型与操作 基本类型：int、float、bool、string、char 等。 列表：[1; 2; 3]，使用分号分隔元素。 元组：(1, \"hello\")，表示异构数据集合。模式匹配模式匹配是 OCaml 的核心特性，用于解构数据和控制流。let rec length lst = match lst with | [] -&gt; 0 | _ :: tail -&gt; 1 + length tail高阶函数支持函数作为参数或返回值。let apply_twice f x = f (f x)let square x = x * xlet result = apply_twice square 3 (* the result is 81 *)模块与函子模块系统支持代码抽象和复用：module type Comparable = sig type t val compare : t -&gt; t -&gt; intendmodule SetMaker (C : Comparable) = struct type t = C.t let compare = C.compareend详细介绍 可以使用let定义变量，但Ocaml中的变量值是不可变的。 =相当于C语言中的双等号==，代表判定等号两侧是否相等。 变量名必须以小写字母或者下划线开头。─( 20:01:58 )─&lt; command 0 &gt;───────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────{ counter: 0 }─utop # let x = 50;;val x : int = 50─( 20:01:58 )─&lt; command 1 &gt;───────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────{ counter: 0 }─utop # x = 50;;- : bool = true─( 20:03:28 )─&lt; command 2 &gt;───────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────{ counter: 0 }─utop # x = 500;;- : bool = false 可以使用let+in的语法来计算函数值。─( 20:03:54 )─&lt; command 3 &gt;───────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────{ counter: 0 }─utop # let x = 100 in x * (x - 1);;- : int = 9900─( 20:15:07 )─&lt; command 4 &gt;───────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────{ counter: 0 }─utop # let x = 10 in let y = 100 in x * y;;- : int = 1000 let也可以用来定义一元函数甚至多元函数。─( 20:17:51 )─&lt; command 5 &gt;───────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────{ counter: 0 }─utop # let square x = x * x;;val square : int -&gt; int = &lt;fun&gt;─( 20:17:53 )─&lt; command 6 &gt;───────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────{ counter: 0 }─utop # let area = square 100;;val area : int = 10000─( 20:18:18 )─&lt; command 7 &gt;───────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────{ counter: 0 }─utop # let multiply x y = x * y;;val multiply : int -&gt; int -&gt; int = &lt;fun&gt; 可以使用let rec来定义递归函数。─( 20:18:33 )─&lt; command 8 &gt;───────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────{ counter: 0 }─utop # let rec range a b = if a &gt; b then [] else a :: range (a + 1) b;;val range : int -&gt; int -&gt; int list = &lt;fun&gt;─( 20:20:21 )─&lt; command 9 &gt;───────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────{ counter: 0 }─utop # let digits = range 0 9;;val digits : int list = [0; 1; 2; 3; 4; 5; 6; 7; 8; 9] Ocaml是强静态类型语言，运行前编译器会自动进行类型推断，基本类型和其他语言类似。 Ocaml中禁止隐式的类型转换。─( 20:23:53 )─&lt; command 10 &gt;──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────{ counter: 0 }─utop # 1 + 1;;- : int = 2─( 20:25:08 )─&lt; command 11 &gt;──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────{ counter: 0 }─utop # 1.0 +. 1.0;;- : float = 2.─( 20:25:17 )─&lt; command 12 &gt;──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────{ counter: 0 }─utop # false;;- : bool = false─( 20:25:47 )─&lt; command 13 &gt;──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────{ counter: 0 }─utop # 's';;- : char = 's'─( 20:26:22 )─&lt; command 14 &gt;──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────{ counter: 0 }─utop # \"Vincent\";;- : string = \"Vincent\" 可以使用模式匹配方便地处理各种情况，非常适合corner case很多的情况。─( 20:27:51 )─&lt; command 15 &gt;──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────{ counter: 0 }─utop # let rec factorial n =match n with| 0 | 1 -&gt; 1| _ -&gt; n * factorial (n - 1);;val factorial : int -&gt; int = &lt;fun&gt;─( 20:51:20 )─&lt; command 16 &gt;──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────{ counter: 0 }─utop # factorial 5;;- : int = 120 列表list─( 20:52:55 )─&lt; command 17 &gt;──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────{ counter: 0 }─utop # [];;- : 'a list = []─( 20:53:12 )─&lt; command 18 &gt;──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────{ counter: 0 }─utop # [1;1];;- : int list = [1; 1]─( 20:55:47 )─&lt; command 19 &gt;──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────{ counter: 0 }─utop # [true;false];;- : bool list = [true; false]─( 20:55:47 )─&lt; command 20 &gt;──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────{ counter: 0 }─utop # [[1;2];[1;2]];;- : int list list = [[1;2];[1;2]] 操作符有::(用来在列表前添加一个元素)和@(用来连接两个列表)。 List的方法hd和tl可以分别获得列表头尾的元素。─( 20:56:02 )─&lt; command 21 &gt;──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────{ counter: 0 }─utop # 1 :: [2;3];;- : int list = [1; 2; 3]─( 20:56:43 )─&lt; command 22 &gt;──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────{ counter: 0 }─utop # [1] @ [2;3];;- : int list = [1; 2; 3]─( 21:00:45 )─&lt; command 23 &gt;──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────{ counter: 0 }─utop # List.hd [1;2;3;4];;- : int = 1─( 21:00:59 )─&lt; command 24 &gt;──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────{ counter: 0 }─utop # List.tl [1;2;3;4];;- : int list = [2; 3; 4] partial application特性，可以给一个多元函数部分参数得到另一个函数。─( 15:27:40 )─&lt; command 1 &gt;──────────────────────────────────────────────────────────────────────────────{ counter: 0 }─utop # let add a b = a + b;;val add : int -&gt; int -&gt; int = &lt;fun&gt;─( 15:30:09 )─&lt; command 2 &gt;──────────────────────────────────────────────────────────────────────────────{ counter: 0 }─utop # let add1 = add 1;;val add1 : int -&gt; int = &lt;fun&gt;─( 15:30:14 )─&lt; command 3 &gt;──────────────────────────────────────────────────────────────────────────────{ counter: 0 }─utop # add1 6;;- : int = 7 元组tuple，可以是不同类型数据的组合，之前的list必须是相同类型元素的组合。 tuple不具备list可以改变长度的特性，tuple的长度是固定的。 自定义枚举类型，注意首字母必须大写。─( 15:31:22 )─&lt; command 4 &gt;───────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────{ counter: 0 }─utop # let tup = (7,\"vincent\",100.00);;val tup : int * string * float = (7, \"vincent\", 100.)─( 15:44:27 )─&lt; command 14 &gt;───────────────────────────────────────────────────────────────{ counter: 0 }─utop # type gender = Male | Female | Helicopter;;type gender = Male | Female | Helicopter─( 15:44:34 )─&lt; command 15 &gt;───────────────────────────────────────────────────────────────{ counter: 0 }─utop # let l =[Male;Female;Helicopter];;val l : gender list = [Male; Female; Helicopter]─( 15:46:07 )─&lt; command 20 &gt;───────────────────────────────────────────────────────────────{ counter: 0 }─utop # type gender = Male | Female | Helicopter | Mixture of int * int * int;;type gender = Male | Female | Helicopter | Mixture of int * int * int─( 15:46:08 )─&lt; command 21 &gt;───────────────────────────────────────────────────────────────{ counter: 0 }─utop # let l =[Male;Female;Helicopter;Mixture (1,2,6)];;val l : gender list = [Male; Female; Helicopter; Mixture (1, 2, 6)] Record类型。─( 15:35:31 )─&lt; command 7 &gt;────────────────────────────────────────────────────────────────{ counter: 0 }─utop # type person = {name:string;nickname:string;age:int;};;type person = { name : string; nickname : string; age : int; }─( 15:39:38 )─&lt; command 8 &gt;────────────────────────────────────────────────────────────────{ counter: 0 }─utop # let vincent = {name = \"vincent\";nickname=\"embracer\";age=20;};;val vincent : person = {name = \"vincent\"; nickname = \"embracer\"; age = 20}─( 17:15:25 )─&lt; command 50 &gt;─────────────────────────────────────────────────────────────────────────────{ counter: 0 }─utop # type person = {name:string;nickname:string;mutable age:int;};;type person = { name : string; nickname : string; mutable age : int; }─( 17:15:31 )─&lt; command 51 &gt;─────────────────────────────────────────────────────────────────────────────{ counter: 0 }─utop # let birthday p = p.age &lt;- p.age + 1;;val birthday : person -&gt; unit = &lt;fun&gt;─( 17:21:54 )─&lt; command 52 &gt;─────────────────────────────────────────────────────────────────────────────{ counter: 0 }─utop # let vincent = {name = \"vincent\";nickname=\"embracer\";age=20;};;val vincent : person = {name = \"vincent\"; nickname = \"embracer\"; age = 20}─( 17:22:50 )─&lt; command 54 &gt;─────────────────────────────────────────────────────────────────────────────{ counter: 0 }─utop # birthday vincent;;- : unit = ()─( 17:23:02 )─&lt; command 55 &gt;─────────────────────────────────────────────────────────────────────────────{ counter: 0 }─utop # vincent;;- : person = {name = \"vincent\"; nickname = \"embracer\"; age = 21} 数据类型具有多态性和递归性 多态性：数据类型可以引用其他的子类型 递归性：数据类型可以递归地引用自身─( 15:49:02 )─&lt; command 22 &gt;──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────{ counter: 0 }─utop # type 'a tree = | Leaf | Node of 'a tree * 'a * 'a tree;;type 'a tree = Leaf | Node of 'a tree * 'a * 'a tree─( 15:49:02 )─&lt; command 23 &gt;─────────────────────────────────────{ counter: 0 }─utop # let rec total t = match t with | Leaf -&gt; 0 | Node (l,x,r) -&gt; total l + x + total r;;val total : int tree -&gt; int = &lt;fun&gt;─( 16:43:13 )─&lt; command 24 &gt;─────────────────────────────────────{ counter: 0 }─utop # let rec reverse t = match t with | Leaf -&gt; Leaf | Node (l,x,r) -&gt; Node (reverse r, x, reverse l);;val reverse : 'a tree -&gt; 'a tree = &lt;fun&gt;─( 16:45:16 )─&lt; command 25 &gt;─────────────────────────────────────{ counter: 0 }─utop # let t = Node(Node(Leaf,1,Leaf),2,Node(Node(Leaf,3,Leaf),4,Node(Leaf,5,Leaf)));;val t : int tree = Node (Node (Leaf, 1, Leaf), 2, Node (Node (Leaf, 3, Leaf), 4, Node (Leaf, 5, Leaf)))─( 16:48:00 )─&lt; command 26 &gt;─────────────────────────────────────{ counter: 0 }─utop # let sum = total t;;val sum : int = 15─( 16:51:09 )─&lt; command 27 &gt;─────────────────────────────────────{ counter: 0 }─utop # let mirror = reverse t;;val mirror : int tree = Node (Node (Node (Leaf, 5, Leaf), 4, Node (Leaf, 3, Leaf)), 2, Node (Leaf, 1, Leaf))─( 16:51:24 )─&lt; command 28 &gt;─────────────────────────────────────{ counter: 0 }─utop # let sum = total mirror;;val sum : int = 15─( 16:51:59 )─&lt; command 29 &gt;─────────────────────────────────────{ counter: 0 }─utop # t = reverse mirror;;- : bool = true 错误处理 可以定义异常exception，同时为其添加子类型。─( 16:56:53 )─&lt; command 32 &gt;─────────────────────────────────────────────────────────────────────────────{ counter: 0 }─utop # exception E;;exception E─( 16:57:01 )─&lt; command 33 &gt;─────────────────────────────────────────────────────────────────────────────{ counter: 0 }─utop # exception E1 of string;;exception E1 of string─( 16:57:33 )─&lt; command 35 &gt;─────────────────────────────────────────────────────────────────────────────{ counter: 0 }─utop # let divide a b = if b = 0 then raise (E1 \"division by zero\") else a / b;;val divide : int -&gt; int -&gt; int = &lt;fun&gt;─( 16:59:27 )─&lt; command 37 &gt;─────────────────────────────────────────────────────────────────────────────{ counter: 0 }─utop # let result = try divide 1 0 with E1 _ -&gt; 0;;val result : int = 0 option类型，类似Rust。─( 16:59:53 )─&lt; command 38 &gt;─────────────────────────────────────────────────────────────────────────────{ counter: 0 }─utop # type 'a option = None | Some of 'a;;type 'a option = None | Some of 'a─( 17:00:06 )─&lt; command 39 &gt;─────────────────────────────────────────────────────────────────────────────{ counter: 0 }─utop # let list_find_option p l = match List.find p l with | v -&gt; Some(v) | exception Not_found -&gt; None;;val list_find_option : ('a -&gt; bool) -&gt; 'a list -&gt; 'a option = &lt;fun&gt; 可变引用。─( 17:09:06 )─&lt; command 41 &gt;─────────────────────────────────────────────────────────────────────────────{ counter: 0 }─utop # let r = ref 50;;val r : int ref = {contents = 50}─( 17:10:58 )─&lt; command 42 &gt;─────────────────────────────────────────────────────────────────────────────{ counter: 0 }─utop # r := 100;;- : unit = ()─( 17:12:50 )─&lt; command 43 &gt;─────────────────────────────────────────────────────────────────────────────{ counter: 0 }─utop # !r;;- : int = 100─( 17:13:01 )─&lt; command 44 &gt;─────────────────────────────────────────────────────────────────────────────{ counter: 0 }─utop # let a = r;;val a : int ref = {contents = 100}─( 17:13:10 )─&lt; command 45 &gt;─────────────────────────────────────────────────────────────────────────────{ counter: 0 }─utop # a := 100;;- : unit = ()─( 17:13:16 )─&lt; command 46 &gt;─────────────────────────────────────────────────────────────────────────────{ counter: 0 }─utop # !r;;- : int = 100 可变数组。─( 17:13:27 )─&lt; command 47 &gt;─────────────────────────────────────────────────────────────────────────────{ counter: 0 }─utop # let arr = [|1;1;1|];;val arr : int array = [|1; 1; 1|]─( 17:13:35 )─&lt; command 48 &gt;─────────────────────────────────────────────────────────────────────────────{ counter: 0 }─utop # arr.(0) &lt;- 100;;- : unit = ()─( 17:15:13 )─&lt; command 49 &gt;─────────────────────────────────────────────────────────────────────────────{ counter: 0 }─utop # arr;;- : int array = [|100; 1; 1|] 示例：列表求和函数。 Ocaml编译器会对模式匹配中忽略的情况发出警告。─( 21:01:33 )─&lt; command 25 &gt;──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────{ counter: 0 }─utop # let rec total l =match l with| [] -&gt; 0| h :: t -&gt; h + total t;;val total : int list -&gt; int = &lt;fun&gt;─( 21:01:37 )─&lt; command 26 &gt;──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────{ counter: 0 }─utop # total [1;2;3;4;5;6;7;8;9];;- : int = 45─( 21:05:14 )─&lt; command 27 &gt;──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────{ counter: 0 }─utop # let rec total l =match l with| h :: t -&gt; h + total t;;Lines 2-3, characters 0-23:Warning 8 [partial-match]: this pattern-matching is not exhaustive.Here is an example of a case that is not matched:[]val total : int list -&gt; int = &lt;fun&gt; 示例：映射函数。─( 21:05:31 )─&lt; command 28 &gt;──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────{ counter: 0 }─utop # let rec map f l =match l with| [] -&gt; []| h :: t -&gt; f h :: map f t;;val map : ('a -&gt; 'b) -&gt; 'a list -&gt; 'b list = &lt;fun&gt; 示例：快速排序(quicksort)算法。let rec quicksort = function | [] -&gt; [] (* 空列表直接返回 *) | pivot :: rest -&gt; let rec partition left right = function | [] -&gt; (left, right) | x :: xs -&gt; if x &lt;= pivot then partition (x :: left) right xs else partition left (x :: right) xs in let (left, right) = partition [] [] rest in quicksort left @ [pivot] @ quicksort right 示例：算式解释器。type expr = | Num of int | Add of expr * expr | Sub of expr * exprlet rec eval = function | Num n -&gt; n | Add (e1, e2) -&gt; eval e1 + eval e2 | Sub (e1, e2) -&gt; eval e1 - eval e2let example = Add (Num 5, Sub (Num 10, Num 3))let result = eval example (* the result is 12 *)OCaml的应用场景OCaml在多个领域有广泛应用，尤其在对类型安全和性能要求高的场景：学术研究 形式化验证：OCaml 是 Coq 定理证明器的实现语言，用于开发形式化验证工具。 编程语言研究：OCaml 的类型系统和模块系统使其成为编译器和解释器开发的理想选择。工业应用 金融系统：如 Jane Street 广泛使用 OCaml 开发高性能交易系统，因其类型安全和低延迟。 静态分析工具：如 Facebook 的 Flow(JavaScript 静态类型检查器)和 Infer(代码分析工具)用 OCaml 实现。 区块链：Tezos 区块链的协议实现大量使用 OCaml。系统编程 MirageOS：一个用 OCaml 编写的轻量级 Unikernel 系统，用于构建高效、安全的操作系统。 编译器与工具：OCaml 自身编译器、FFmpeg 的部分组件等都用 OCaml 编写。OCaml学习资源 官方文档：OCaml 官方网站提供教程和参考手册。 书籍： 《Real World OCaml》：面向实际应用的 OCaml 教程。 《OCaml from the Very Beginning》：适合初学者。 工具： opam：安装 OCaml 和管理依赖。 dune：现代构建工具。 utop：交互式 REPL，适合学习和实验。 社区：OCaml Discourse、Reddit 和 Stack Overflow 上的 OCaml 标签。" }, { "title": "A Try on Reverse Engineering | Vincent's Technical Reports (Vol. 1)", "url": "/posts/Reverse_Engineering/", "categories": "Vincent's Technical Reports", "tags": "Reverse Engineering, LLM, Decompiler", "date": "2025-05-27 16:30:00 +0000", "snippet": "一次有趣的逆向工程经历前因在五道口技术学院某抽象院系的某课程的一次作业中，出现了有趣的情况。作业要求监测某可执行文件运行过程中的数据，再用数据推测得到助教提前设置好的两个信息。提供给同学们下载的是编译好的可执行文件，而不是源代码，不然可以直接阅读源码获得答案。同时，这个可执行文件运行需要一个参数，助教规定每个同学将参数设置为自己的学号。这是为了保证同学们的答案不全相同来防止抄袭，但也可以推测...", "content": "一次有趣的逆向工程经历前因在五道口技术学院某抽象院系的某课程的一次作业中，出现了有趣的情况。作业要求监测某可执行文件运行过程中的数据，再用数据推测得到助教提前设置好的两个信息。提供给同学们下载的是编译好的可执行文件，而不是源代码，不然可以直接阅读源码获得答案。同时，这个可执行文件运行需要一个参数，助教规定每个同学将参数设置为自己的学号。这是为了保证同学们的答案不全相同来防止抄袭，但也可以推测出正确答案是输入参数的某个函数。使用objdump进行反汇编// -d 选项指示 objdump 对目标文件中包含可执行代码的节（section）进行反汇编// 将机器码转换为对应架构的汇编指令。 // -C 选项用于解析编译器对符号名进行的名称修饰（name mangling）// 将修饰后的符号名转换为原始可读的函数名，如 foo(int, int)/lipsum()objdump -d -C ./main执行命令后得到本次所关注的lipsum()函数和main函数。0000000000001150 &lt;main&gt;: 1150: 41 54 push %r12 1152: 55 push %rbp 1153: 48 83 ec 18 sub $0x18,%rsp 1157: 89 7c 24 0c mov %edi,0xc(%rsp) 115b: 48 8d 7c 24 0c lea 0xc(%rsp),%rdi 1160: 48 89 34 24 mov %rsi,(%rsp) 1164: 48 89 e6 mov %rsp,%rsi 1167: e8 94 ff ff ff call 1100 &lt;MPI_Init@plt&gt; 116c: 48 8d 35 91 5e d4 41 lea 0x41d45e91(%rip),%rsi # 41d47004 &lt;mpiSize&gt; 1173: bf 00 00 00 44 mov $0x44000000,%edi 1178: e8 33 ff ff ff call 10b0 &lt;MPI_Comm_size@plt&gt; 117d: 48 8d 35 84 5e d4 41 lea 0x41d45e84(%rip),%rsi # 41d47008 &lt;mpiRank&gt; 1184: bf 00 00 00 44 mov $0x44000000,%edi 1189: e8 62 ff ff ff call 10f0 &lt;MPI_Comm_rank@plt&gt; 118e: 83 3d 6f 5e d4 41 08 cmpl $0x8,0x41d45e6f(%rip) # 41d47004 &lt;mpiSize&gt; 1195: 0f 85 83 01 00 00 jne 131e &lt;main+0x1ce&gt; 119b: 83 7c 24 0c 02 cmpl $0x2,0xc(%rsp) 11a0: 0f 85 56 01 00 00 jne 12fc &lt;main+0x1ac&gt; 11a6: 48 8b 04 24 mov (%rsp),%rax 11aa: 31 f6 xor %esi,%esi 11ac: ba 0a 00 00 00 mov $0xa,%edx 11b1: 48 8b 78 08 mov 0x8(%rax),%rdi 11b5: e8 26 ff ff ff call 10e0 &lt;strtol@plt&gt; 11ba: 89 05 40 5e d4 41 mov %eax,0x41d45e40(%rip) # 41d47000 &lt;id&gt; 11c0: 48 89 c1 mov %rax,%rcx 11c3: 89 c6 mov %eax,%esi 11c5: 85 c0 test %eax,%eax 11c7: 0f 88 39 01 00 00 js 1306 &lt;main+0x1b6&gt; 11cd: 49 b8 e5 8f a2 12 31 movabs $0x89705f3112a28fe5,%r8 11d4: 5f 70 89 11d7: bf 0a 00 00 00 mov $0xa,%edi 11dc: 0f 1f 40 00 nopl 0x0(%rax) 11e0: 48 63 f6 movslq %esi,%rsi 11e3: 48 63 c9 movslq %ecx,%rcx 11e6: 48 69 f6 17 27 00 00 imul $0x2717,%rsi,%rsi 11ed: 48 69 c9 17 27 00 00 imul $0x2717,%rcx,%rcx 11f4: 48 83 c6 07 add $0x7,%rsi 11f8: 48 89 f0 mov %rsi,%rax 11fb: 48 83 c1 09 add $0x9,%rcx 11ff: 49 f7 e0 mul %r8 1202: 48 83 f1 01 xor $0x1,%rcx 1206: 48 89 c8 mov %rcx,%rax 1209: 48 c1 ea 1d shr $0x1d,%rdx 120d: 48 69 d2 07 ca 9a 3b imul $0x3b9aca07,%rdx,%rdx 1214: 29 d6 sub %edx,%esi 1216: 49 f7 e0 mul %r8 1219: 48 c1 ea 1d shr $0x1d,%rdx 121d: 48 69 d2 07 ca 9a 3b imul $0x3b9aca07,%rdx,%rdx 1224: 29 d1 sub %edx,%ecx 1226: 83 ef 01 sub $0x1,%edi 1229: 75 b5 jne 11e0 &lt;main+0x90&gt; 122b: 83 e6 07 and $0x7,%esi 122e: 83 e1 01 and $0x1,%ecx 1231: 89 35 dd 2d 00 00 mov %esi,0x2ddd(%rip) # 4014 &lt;slowRank&gt; 1237: 89 0d d3 2d 00 00 mov %ecx,0x2dd3(%rip) # 4010 &lt;workloadType&gt; 123d: e8 4e 02 00 00 call 1490 &lt;init()&gt; 1242: bf 00 00 00 44 mov $0x44000000,%edi 1247: e8 14 fe ff ff call 1060 &lt;MPI_Barrier@plt&gt; 124c: e8 bf 02 00 00 call 1510 &lt;lipsum()&gt; 1251: bf 00 00 00 44 mov $0x44000000,%edi 1256: e8 05 fe ff ff call 1060 &lt;MPI_Barrier@plt&gt; 125b: e8 10 fe ff ff call 1070 &lt;MPI_Finalize@plt&gt; 1260: 8b 05 a2 5d d4 41 mov 0x41d45da2(%rip),%eax # 41d47008 &lt;mpiRank&gt; 1266: 85 c0 test %eax,%eax 1268: 74 0a je 1274 &lt;main+0x124&gt; 126a: 48 83 c4 18 add $0x18,%rsp 126e: 31 c0 xor %eax,%eax 1270: 5d pop %rbp 1271: 41 5c pop %r12 1273: c3 ret 1274: 48 8d 35 c7 0d 00 00 lea 0xdc7(%rip),%rsi # 2042 &lt;_IO_stdin_used+0x42&gt; 127b: 48 8d 3d be 2d 00 00 lea 0x2dbe(%rip),%rdi # 4040 &lt;std::cout@GLIBCXX_3.4&gt; 1282: e8 09 fe ff ff call 1090 &lt;std::basic_ostream&lt;char, std::char_traits&lt;char&gt; &gt;&amp; std::operator&lt;&lt; &lt;std::char_traits&lt;char&gt; &gt;(std::basic_ostream&lt;char, std::char_traits&lt;char&gt; &gt;&amp;, char const*)@plt&gt; 1287: 8b 35 73 5d d4 41 mov 0x41d45d73(%rip),%esi # 41d47000 &lt;id&gt; 128d: 48 89 c7 mov %rax,%rdi 1290: e8 9b fe ff ff call 1130 &lt;std::ostream::operator&lt;&lt;(int)@plt&gt; 1295: 48 89 c5 mov %rax,%rbp 1298: 48 8b 00 mov (%rax),%rax 129b: 48 8b 40 e8 mov -0x18(%rax),%rax 129f: 4c 8b a4 05 f0 00 00 mov 0xf0(%rbp,%rax,1),%r12 12a6: 00 12a7: 4d 85 e4 test %r12,%r12 12aa: 74 6d je 1319 &lt;main+0x1c9&gt; 12ac: 41 80 7c 24 38 00 cmpb $0x0,0x38(%r12) 12b2: 74 1b je 12cf &lt;main+0x17f&gt; 12b4: 41 0f b6 44 24 43 movzbl 0x43(%r12),%eax 12ba: 48 89 ef mov %rbp,%rdi 12bd: 0f be f0 movsbl %al,%esi 12c0: e8 6b fd ff ff call 1030 &lt;std::ostream::put(char)@plt&gt; 12c5: 48 89 c7 mov %rax,%rdi 12c8: e8 83 fd ff ff call 1050 &lt;std::ostream::flush()@plt&gt; 12cd: eb 9b jmp 126a &lt;main+0x11a&gt; 12cf: 4c 89 e7 mov %r12,%rdi 12d2: e8 c9 fd ff ff call 10a0 &lt;std::ctype&lt;char&gt;::_M_widen_init() const@plt&gt; 12d7: 49 8b 04 24 mov (%r12),%rax 12db: 48 8d 0d ce 04 00 00 lea 0x4ce(%rip),%rcx # 17b0 &lt;std::ctype&lt;char&gt;::do_widen(char) const&gt; 12e2: 48 8b 50 30 mov 0x30(%rax),%rdx 12e6: b8 0a 00 00 00 mov $0xa,%eax 12eb: 48 39 ca cmp %rcx,%rdx 12ee: 74 ca je 12ba &lt;main+0x16a&gt; 12f0: be 0a 00 00 00 mov $0xa,%esi 12f5: 4c 89 e7 mov %r12,%rdi 12f8: ff d2 call *%rdx 12fa: eb be jmp 12ba &lt;main+0x16a&gt; 12fc: c7 05 fa 5c d4 41 ff movl $0xffffffff,0x41d45cfa(%rip) # 41d47000 &lt;id&gt; 1303: ff ff ff 1306: 83 3d fb 5c d4 41 00 cmpl $0x0,0x41d45cfb(%rip) # 41d47008 &lt;mpiRank&gt; 130d: 74 34 je 1343 &lt;main+0x1f3&gt; 130f: bf 01 00 00 00 mov $0x1,%edi 1314: e8 a7 fd ff ff call 10c0 &lt;exit@plt&gt; 1319: e8 b2 fd ff ff call 10d0 &lt;std::__throw_bad_cast()@plt&gt; 131e: 83 3d e3 5c d4 41 00 cmpl $0x0,0x41d45ce3(%rip) # 41d47008 &lt;mpiRank&gt; 1325: 75 e8 jne 130f &lt;main+0x1bf&gt; 1327: 48 8b 3d 32 2e 00 00 mov 0x2e32(%rip),%rdi # 4160 &lt;stderr@GLIBC_2.2.5&gt; 132e: ba 08 00 00 00 mov $0x8,%edx 1333: 48 8d 35 ce 0c 00 00 lea 0xcce(%rip),%rsi # 2008 &lt;_IO_stdin_used+0x8&gt; 133a: 31 c0 xor %eax,%eax 133c: e8 cf fd ff ff call 1110 &lt;fprintf@plt&gt; 1341: eb cc jmp 130f &lt;main+0x1bf&gt; 1343: 48 8b 04 24 mov (%rsp),%rax 1347: 48 8b 3d 12 2e 00 00 mov 0x2e12(%rip),%rdi # 4160 &lt;stderr@GLIBC_2.2.5&gt; 134e: 48 8d 35 d5 0c 00 00 lea 0xcd5(%rip),%rsi # 202a &lt;_IO_stdin_used+0x2a&gt; 1355: 48 8b 10 mov (%rax),%rdx 1358: 31 c0 xor %eax,%eax 135a: e8 b1 fd ff ff call 1110 &lt;fprintf@plt&gt; 135f: eb ae jmp 130f &lt;main+0x1bf&gt; 1361: 66 66 2e 0f 1f 84 00 data16 cs nopw 0x0(%rax,%rax,1) 1368: 00 00 00 00 136c: 0f 1f 40 00 nopl 0x0(%rax)0000000000001510 &lt;lipsum()&gt;: 1510: 41 57 push %r15 1512: 41 56 push %r14 1514: 41 55 push %r13 1516: 41 54 push %r12 1518: 55 push %rbp 1519: 53 push %rbx 151a: 48 83 ec 18 sub $0x18,%rsp 151e: 8b 0d ec 2a 00 00 mov 0x2aec(%rip),%ecx # 4010 &lt;workloadType&gt; 1524: 8b 15 de 5a d4 41 mov 0x41d45ade(%rip),%edx # 41d47008 &lt;mpiRank&gt; 152a: 8b 05 e4 2a 00 00 mov 0x2ae4(%rip),%eax # 4014 &lt;slowRank&gt; 1530: 85 c9 test %ecx,%ecx 1532: 0f 85 49 01 00 00 jne 1681 &lt;lipsum()+0x171&gt; 1538: 48 63 0d c1 5a d4 41 movslq 0x41d45ac1(%rip),%rcx # 41d47000 &lt;id&gt; 153f: 39 c2 cmp %eax,%edx 1541: be 70 17 00 00 mov $0x1770,%esi 1546: b8 b8 0b 00 00 mov $0xbb8,%eax 154b: 48 0f 45 f0 cmovne %rax,%rsi 154f: 48 8d 3d ea 74 f8 0b lea 0xbf874ea(%rip),%rdi # bf88a40 &lt;ci&gt; 1556: 48 ba 0b d7 a3 70 3d movabs $0xa3d70a3d70a3d70b,%rdx 155d: 0a d7 a3 1560: bb 64 00 00 00 mov $0x64,%ebx 1565: 48 69 c9 17 27 00 00 imul $0x2717,%rcx,%rcx 156c: 4c 8d 2d 0d 6f f0 17 lea 0x17f06f0d(%rip),%r13 # 17f08480 &lt;ai&gt; 1573: 4c 8d 3d e6 71 f4 11 lea 0x11f471e6(%rip),%r15 # 11f48760 &lt;bi&gt; 157a: 48 89 c8 mov %rcx,%rax 157d: 48 f7 ea imul %rdx 1580: 48 8d 04 0a lea (%rdx,%rcx,1),%rax 1584: 48 89 ca mov %rcx,%rdx 1587: 48 c1 fa 3f sar $0x3f,%rdx 158b: 48 c1 f8 06 sar $0x6,%rax 158f: 48 29 d0 sub %rdx,%rax 1592: 48 8d 04 80 lea (%rax,%rax,4),%rax 1596: 48 8d 14 80 lea (%rax,%rax,4),%rdx 159a: 48 89 c8 mov %rcx,%rax 159d: 48 c1 e2 02 shl $0x2,%rdx 15a1: 48 29 d0 sub %rdx,%rax 15a4: 48 ba c3 f5 28 5c 8f movabs $0x28f5c28f5c28f5c3,%rdx 15ab: c2 f5 28 15ae: 48 05 aa 00 00 00 add $0xaa,%rax 15b4: 48 0f af c6 imul %rsi,%rax 15b8: 48 c1 e8 03 shr $0x3,%rax 15bc: 48 f7 e2 mul %rdx 15bf: 48 89 d0 mov %rdx,%rax 15c2: 48 c1 e8 02 shr $0x2,%rax 15c6: 41 89 c6 mov %eax,%r14d 15c9: 48 8d 2c 85 00 00 00 lea 0x0(,%rax,4),%rbp 15d0: 00 15d1: 41 89 c4 mov %eax,%r12d 15d4: 4d 69 f6 1f 85 eb 51 imul $0x51eb851f,%r14,%r14 15db: 85 c0 test %eax,%eax 15dd: b8 04 00 00 00 mov $0x4,%eax 15e2: 48 0f 4f c5 cmovg %rbp,%rax 15e6: 31 ed xor %ebp,%ebp 15e8: 48 89 44 24 08 mov %rax,0x8(%rsp) 15ed: 49 c1 ee 25 shr $0x25,%r14 15f1: 0f 1f 80 00 00 00 00 nopl 0x0(%rax) 15f8: 48 8b 54 24 08 mov 0x8(%rsp),%rdx 15fd: 31 f6 xor %esi,%esi 15ff: e8 3c fa ff ff call 1040 &lt;memset@plt&gt; 1604: 45 31 c9 xor %r9d,%r9d 1607: 48 89 c7 mov %rax,%rdi 160a: 66 0f 1f 44 00 00 nopw 0x0(%rax,%rax,1) 1610: 31 f6 xor %esi,%esi 1612: 31 c9 xor %ecx,%ecx 1614: 0f 1f 40 00 nopl 0x0(%rax) 1618: 69 c3 17 27 00 00 imul $0x2717,%ebx,%eax 161e: 05 d5 00 00 00 add $0xd5,%eax 1623: 99 cltd 1624: 41 f7 fc idiv %r12d 1627: 48 63 c2 movslq %edx,%rax 162a: 48 63 d1 movslq %ecx,%rdx 162d: 48 89 c3 mov %rax,%rbx 1630: 48 69 c0 92 13 00 00 imul $0x1392,%rax,%rax 1637: 48 01 d0 add %rdx,%rax 163a: 41 8b 54 8d 00 mov 0x0(%r13,%rcx,4),%edx 163f: 48 83 c1 01 add $0x1,%rcx 1643: 41 0f af 14 87 imul (%r15,%rax,4),%edx 1648: 01 d6 add %edx,%esi 164a: 4c 39 f1 cmp %r14,%rcx 164d: 75 c9 jne 1618 &lt;lipsum()+0x108&gt; 164f: 42 89 34 8f mov %esi,(%rdi,%r9,4) 1653: 49 83 c1 01 add $0x1,%r9 1657: 45 39 cc cmp %r9d,%r12d 165a: 7f b4 jg 1610 &lt;lipsum()+0x100&gt; 165c: 83 c5 01 add $0x1,%ebp 165f: 48 81 c7 48 4e 00 00 add $0x4e48,%rdi 1666: 49 81 c5 48 4e 00 00 add $0x4e48,%r13 166d: 44 39 e5 cmp %r12d,%ebp 1670: 7c 86 jl 15f8 &lt;lipsum()+0xe8&gt; 1672: 48 83 c4 18 add $0x18,%rsp 1676: 5b pop %rbx 1677: 5d pop %rbp 1678: 41 5c pop %r12 167a: 41 5d pop %r13 167c: 41 5e pop %r14 167e: 41 5f pop %r15 1680: c3 ret 1681: 48 63 0d 78 59 d4 41 movslq 0x41d45978(%rip),%rcx # 41d47000 &lt;id&gt; 1688: 39 c2 cmp %eax,%edx 168a: be d0 07 00 00 mov $0x7d0,%esi 168f: b8 e8 03 00 00 mov $0x3e8,%eax 1694: 48 0f 45 f0 cmovne %rax,%rsi 1698: 48 8d 3d 01 6b ec 1d lea 0x1dec6b01(%rip),%rdi # 1dec81a0 &lt;cd&gt; 169f: 48 ba 0b d7 a3 70 3d movabs $0xa3d70a3d70a3d70b,%rdx 16a6: 0a d7 a3 16a9: 48 69 c9 17 27 00 00 imul $0x2717,%rcx,%rcx 16b0: 48 8d 2d 29 5f dc 35 lea 0x35dc5f29(%rip),%rbp # 35dc75e0 &lt;ad&gt; 16b7: 48 89 c8 mov %rcx,%rax 16ba: 48 f7 ea imul %rdx 16bd: 48 8d 04 0a lea (%rdx,%rcx,1),%rax 16c1: 48 89 ca mov %rcx,%rdx 16c4: 48 c1 fa 3f sar $0x3f,%rdx 16c8: 48 c1 f8 06 sar $0x6,%rax 16cc: 48 29 d0 sub %rdx,%rax 16cf: 48 8d 04 80 lea (%rax,%rax,4),%rax 16d3: 48 8d 14 80 lea (%rax,%rax,4),%rdx 16d7: 48 89 c8 mov %rcx,%rax 16da: 48 c1 e2 02 shl $0x2,%rdx 16de: 48 29 d0 sub %rdx,%rax 16e1: 48 ba c3 f5 28 5c 8f movabs $0x28f5c28f5c28f5c3,%rdx 16e8: c2 f5 28 16eb: 48 05 aa 00 00 00 add $0xaa,%rax 16f1: 48 0f af c6 imul %rsi,%rax 16f5: 48 c1 e8 03 shr $0x3,%rax 16f9: 48 f7 e2 mul %rdx 16fc: 48 89 d0 mov %rdx,%rax 16ff: 48 c1 e8 02 shr $0x2,%rax 1703: 85 c0 test %eax,%eax 1705: 4c 8d 24 c5 00 00 00 lea 0x0(,%rax,8),%r12 170c: 00 170d: 89 c3 mov %eax,%ebx 170f: b8 08 00 00 00 mov $0x8,%eax 1714: 4c 0f 4e e0 cmovle %rax,%r12 1718: 45 31 ed xor %r13d,%r13d 171b: 0f 1f 44 00 00 nopl 0x0(%rax,%rax,1) 1720: 4c 89 e2 mov %r12,%rdx 1723: 31 f6 xor %esi,%esi 1725: e8 16 f9 ff ff call 1040 &lt;memset@plt&gt; 172a: 48 8d 15 8f 64 e4 29 lea 0x29e4648f(%rip),%rdx # 29e47bc0 &lt;bd&gt; 1731: 31 c9 xor %ecx,%ecx 1733: 66 0f ef d2 pxor %xmm2,%xmm2 1737: 48 89 c7 mov %rax,%rdi 173a: 66 0f 1f 44 00 00 nopw 0x0(%rax,%rax,1) 1740: 31 c0 xor %eax,%eax 1742: 66 0f 28 ca movapd %xmm2,%xmm1 1746: 66 2e 0f 1f 84 00 00 cs nopw 0x0(%rax,%rax,1) 174d: 00 00 00 1750: f2 0f 10 44 c5 00 movsd 0x0(%rbp,%rax,8),%xmm0 1756: f2 0f 59 04 c2 mulsd (%rdx,%rax,8),%xmm0 175b: 48 83 c0 01 add $0x1,%rax 175f: f2 0f 58 c8 addsd %xmm0,%xmm1 1763: 39 c3 cmp %eax,%ebx 1765: 7f e9 jg 1750 &lt;lipsum()+0x240&gt; 1767: f2 0f 11 0c cf movsd %xmm1,(%rdi,%rcx,8) 176c: 48 83 c1 01 add $0x1,%rcx 1770: 48 81 c2 90 9c 00 00 add $0x9c90,%rdx 1777: 39 cb cmp %ecx,%ebx 1779: 7f c5 jg 1740 &lt;lipsum()+0x230&gt; 177b: 41 83 c5 01 add $0x1,%r13d 177f: 48 81 c7 90 9c 00 00 add $0x9c90,%rdi 1786: 48 81 c5 90 9c 00 00 add $0x9c90,%rbp 178d: 41 39 dd cmp %ebx,%r13d 1790: 7c 8e jl 1720 &lt;lipsum()+0x210&gt; 1792: 48 83 c4 18 add $0x18,%rsp 1796: 5b pop %rbx 1797: 5d pop %rbp 1798: 41 5c pop %r12 179a: 41 5d pop %r13 179c: 41 5e pop %r14 179e: 41 5f pop %r15 17a0: c3 ret 17a1: 66 2e 0f 1f 84 00 00 cs nopw 0x0(%rax,%rax,1) 17a8: 00 00 00 17ab: 0f 1f 44 00 00 nopl 0x0(%rax,%rax,1)使用Ghidra进行反编译得到lipsum()函数和main函数的等效源代码，得出的源码可读性还比较差，我们还需要进一步处理。undefined8 main(int param_1, undefined8 *param_2){ long *plVar1; ulong uVar2; basic_ostream *this; long *plVar3; uint uVar4; uint uVar5; ulong uVar6; int iVar7; undefined8 *local_28; int local_1c[3]; local_28 = param_2; local_1c[0] = param_1; MPI_Init(local_1c, &amp;local_28); MPI_Comm_size(0x44000000, &amp;mpiSize); MPI_Comm_rank(0x44000000); if (mpiSize == 8) { if (local_1c[0] == 2) { uVar2 = strtol((char *)local_28[1], (char **)0x0, 10); id = (int)uVar2; uVar6 = uVar2 &amp; 0xffffffff; if (-1 &lt; id) { iVar7 = 10; do { uVar6 = (long)(int)uVar6 * 0x2717 + 7; uVar2 = (long)(int)uVar2 * 0x2717 + 9U ^ 1; uVar5 = (int)uVar6 + (int)(uVar6 / 0x3b9aca07) * -0x3b9aca07; uVar6 = (ulong)uVar5; uVar4 = (int)uVar2 + (int)(uVar2 / 0x3b9aca07) * -0x3b9aca07; uVar2 = (ulong)uVar4; iVar7 = iVar7 + -1; } while (iVar7 != 0); slowRank = uVar5 &amp; 7; workloadType = uVar4 &amp; 1; init(); MPI_Barrier(0x44000000); lipsum(); MPI_Barrier(0x44000000); MPI_Finalize(); if (mpiRank != 0) { return 0; } this = std::operator&lt;&lt;((basic_ostream *)std::cout, \"Sucesss \"); plVar3 = (long *)std::basic_ostream&lt;char, std::char_traits&lt;char&gt;&gt;::operator&lt;&lt; ((basic_ostream&lt;char, std::char_traits&lt;char&gt;&gt; *)this, id); plVar1 = *(long **)((long)plVar3 + *(long *)(*plVar3 + -0x18) + 0xf0); if (plVar1 != (long *)0x0) { if (*(char *)(plVar1 + 7) == '\\0') { std::ctype&lt;char&gt;::_M_widen_init(); if (*(code **)(*plVar1 + 0x30) != std::ctype&lt;char&gt;::do_widen) { (**(code **)(*plVar1 + 0x30))(plVar1, 10); } } std::basic_ostream&lt;char, std::char_traits&lt;char&gt;&gt;::put((char)plVar3); std::basic_ostream&lt;char, std::char_traits&lt;char&gt;&gt;::flush(); return 0; } std::__throw_bad_cast(); goto LAB_0010131e; } } else { id = -1; } if (mpiRank == 0) { fprintf(stderr, \"Usage: %s &lt;Student ID&gt;\\n\", *local_28); } } else { LAB_0010131e: if (mpiRank == 0) { fprintf(stderr, \"Please run with %d MPI prcoesses\\n\", 8); } } /* WARNING: Subroutine does not return */ exit(1);}/* WARNING: Unknown calling convention -- yet parameter storage is locked *//* lipsum() */void lipsum(void){ long lVar1; long lVar2; int iVar3; ulong uVar4; void *pvVar5; int iVar6; ulong uVar7; long lVar8; int iVar9; int iVar10; long lVar11; undefined1 *puVar12; size_t sVar13; undefined1 *puVar14; double dVar15; if (workloadType == 0) { lVar11 = 6000; if (mpiRank != slowRank) { lVar11 = 3000; } puVar12 = ci; lVar8 = 100; puVar14 = ai; uVar4 = (ulong)((((long)id * 0x2717) % 100 + 0xaa) * lVar11) / 200; iVar3 = (int)uVar4; sVar13 = 4; if (0 &lt; iVar3) { sVar13 = uVar4 * 4; } iVar9 = 0; do { pvVar5 = memset(puVar12, 0, sVar13); lVar11 = 0; do { iVar10 = 0; uVar7 = 0; do { lVar8 = (long)(((int)lVar8 * 0x2717 + 0xd5) % iVar3); iVar6 = (int)uVar7; lVar1 = uVar7 * 4; uVar7 = uVar7 + 1; iVar10 = iVar10 + *(int *)(puVar14 + lVar1) * *(int *)(bi + (lVar8 * 0x1392 + (long)iVar6) * 4); } while (uVar7 != (uVar4 &amp; 0xffffffff) / 100); *(int *)((long)pvVar5 + lVar11 * 4) = iVar10; lVar11 = lVar11 + 1; } while ((int)lVar11 &lt; iVar3); iVar9 = iVar9 + 1; puVar12 = (undefined1 *)((long)pvVar5 + 0x4e48); puVar14 = puVar14 + 0x4e48; } while (iVar9 &lt; iVar3); return; } lVar11 = 2000; if (mpiRank != slowRank) { lVar11 = 1000; } puVar14 = cd; puVar12 = ad; uVar4 = (ulong)((((long)id * 0x2717) % 100 + 0xaa) * lVar11) / 200; iVar3 = (int)uVar4; sVar13 = uVar4 * 8; if (iVar3 &lt; 1) { sVar13 = 8; } iVar9 = 0; do { pvVar5 = memset(puVar14, 0, sVar13); puVar14 = bd; lVar11 = 0; do { lVar8 = 0; dVar15 = 0.0; do { lVar2 = lVar8 * 8; lVar1 = lVar8 * 8; lVar8 = lVar8 + 1; dVar15 = dVar15 + *(double *)(puVar12 + lVar2) * *(double *)(puVar14 + lVar1); } while ((int)lVar8 &lt; iVar3); *(double *)((long)pvVar5 + lVar11 * 8) = dVar15; lVar11 = lVar11 + 1; puVar14 = puVar14 + 0x9c90; } while ((int)lVar11 &lt; iVar3); iVar9 = iVar9 + 1; puVar14 = (undefined1 *)((long)pvVar5 + 0x9c90); puVar12 = puVar12 + 0x9c90; } while (iVar9 &lt; iVar3); return;}使用Grok3大模型进行整理把这段可读性极差的代码交给Grok3大模型进行整理，得到最后近似版的源代码，真相终于浮出水面。#include &lt;mpi.h&gt;#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;// 全局变量（根据反编译代码推测）int id = -1; // 学生 ID 或输入参数int mpiRank; // 当前进程的 MPI 排名int mpiSize; // MPI 进程总数int slowRank; // 慢速进程的排名int workloadType; // 工作负载类型（0 或 1）int* ai; // 输入数组（整数）int* bi; // 输入数组（整数）int* ci; // 输出数组（整数）double* ad; // 输入数组（浮点数）double* bd; // 输入数组（浮点数）double* cd; // 输出数组（浮点数）// 工作负载函数void lipsum() { if (workloadType == 0) { // 整数运算工作负载 int iterations = (mpiRank == slowRank) ? 6000 : 3000; // 慢速进程迭代更多 int size = (((id * 0x2717) % 100 + 0xAA) * iterations) / 200; // 计算数组大小 size_t bufferSize = (size &gt; 0) ? size * sizeof(int) : 4 * sizeof(int); int* output = ci; // 输出缓冲区 int* inputA = ai; // 输入缓冲区 A for (int i = 0; i &lt; size; ++i) { memset(output, 0, bufferSize); // 清零输出缓冲区 long seed = 100; // 初始种子 for (int j = 0; j &lt; size; ++j) { int sum = 0; for (int k = 0; k &lt; size / 100; ++k) { seed = ((seed * 0x2717 + 0xD5) % size); // 更新种子 sum += inputA[k * sizeof(int)] * bi[(seed * 0x1392 + k) * sizeof(int) / sizeof(int)]; } output[j] = sum; } output += 0x4E48 / sizeof(int); // 移动到下一块缓冲区 inputA += 0x4E48 / sizeof(int); } } else { // 浮点运算工作负载 int iterations = (mpiRank == slowRank) ? 2000 : 1000; // 慢速进程迭代更多 int size = (((id * 0x2717) % 100 + 0xAA) * iterations) / 200; // 计算数组大小 size_t bufferSize = (size &gt; 0) ? size * sizeof(double) : 8 * sizeof(double); double* output = cd; // 输出缓冲区 double* inputA = ad; // 输入缓冲区 A double* inputB = bd; // 输入缓冲区 B for (int i = 0; i &lt; size; ++i) { memset(output, 0, bufferSize); // 清零输出缓冲区 for (int j = 0; j &lt; size; ++j) { double sum = 0.0; for (int k = 0; k &lt; size; ++k) { sum += inputA[k] * inputB[k]; } output[j] = sum; inputB += 0x9C90 / sizeof(double); // 移动到下一块缓冲区 } output += 0x9C90 / sizeof(double); // 移动到下一块缓冲区 inputA += 0x9C90 / sizeof(double); } }}int main(int argc, char* argv[]) { // 初始化 MPI MPI_Init(&amp;argc, &amp;argv); MPI_Comm_size(MPI_COMM_WORLD, &amp;mpiSize); // 获取进程总数 MPI_Comm_rank(MPI_COMM_WORLD, &amp;mpiRank); // 获取当前进程排名 // 检查是否使用 8 个 MPI 进程 if (mpiSize != 8) { if (mpiRank == 0) { fprintf(stderr, \"Please run with %d MPI processes\\n\", 8); } MPI_Finalize(); exit(1); } // 检查命令行参数 if (argc == 2) { id = std::atoi(argv[1]); // 解析学生 ID if (id &gt;= 0) { // 计算 slowRank 和 workloadType unsigned int seed1 = id; unsigned int seed2 = id; for (int i = 0; i &lt; 10; ++i) { seed1 = seed1 * 0x2717 + 7; // 更新种子 1 seed2 = (seed2 * 0x2717 + 9) ^ 1; // 更新种子 2 seed1 = seed1 % 0x3B9ACA07; // 模运算 seed2 = seed2 % 0x3B9ACA07; } slowRank = seed1 &amp; 7; // 确定慢速进程 workloadType = seed2 &amp; 1; // 确定工作负载类型（0 或 1） // 执行工作负载 init(); MPI_Barrier(MPI_COMM_WORLD); // 同步 lipsum(); MPI_Barrier(MPI_COMM_WORLD); // 同步 MPI_Finalize(); // 主进程输出结果 if (mpiRank == 0) { std::cout &lt;&lt; \"Success \" &lt;&lt; id &lt;&lt; std::endl; } return 0; } } // 参数错误处理 if (mpiRank == 0) { fprintf(stderr, \"Usage: %s &lt;Student ID&gt;\\n\", argv[0]); } MPI_Finalize(); exit(1);}可以发现依赖于输入参数的全局变量有两个分别是slowRank 和 workloadType，lipsum()函数会根据这两个参数来执行不同的逻辑，前者决定八个进程中哪个进程设置为慢速进程，后者决定工作负载种类是整数运算还是浮点运算，具体截取如下。#include &lt;mpi.h&gt;#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;//...int slowRank; // 慢速进程的排名int workloadType; // 工作负载类型（0 或 1）// 工作负载函数void lipsum() { if (workloadType == 0) { // 整数运算工作负载 int iterations = (mpiRank == slowRank) ? 6000 : 3000; // 慢速进程迭代更多\t\t//... } } else { // 浮点运算工作负载 int iterations = (mpiRank == slowRank) ? 2000 : 1000; // 慢速进程迭代更多 //... }}int main(int argc, char* argv[]) {\t//... // 检查命令行参数 //... id = std::atoi(argv[1]); // 解析学生 ID if (id &gt;= 0) { // 计算 slowRank 和 workloadType unsigned int seed1 = id; unsigned int seed2 = id; for (int i = 0; i &lt; 10; ++i) { seed1 = seed1 * 0x2717 + 7; // 更新种子 1 seed2 = (seed2 * 0x2717 + 9) ^ 1; // 更新种子 2 seed1 = seed1 % 0x3B9ACA07; // 模运算 seed2 = seed2 % 0x3B9ACA07; } slowRank = seed1 &amp; 7; // 确定慢速进程 workloadType = seed2 &amp; 1; // 确定工作负载类型（0 或 1） //... } //... // 参数错误处理\t//...}将十六进制转化为十进制，我们可以看到真正的逻辑如下。 // 参数为同学学号\tval1 = studentId; val2 = studentId; // Perform the calculations for(int i = 0; i &lt; 10; i++) { val1 = (val1 * 10007 + 7) % 1000000007; val2 = (val2 * 10007 + 9) % 1000000007; } // Calculate task allocation parameters slowRank = val1 % 8; workloadType = val2 % 2;总结一次有趣的逆向工程之旅就这样结束了，我们可以给逆向工程（Reverse Engineering）下一个定义：在不依赖原始设计文档或源代码的情况下，分析一个已有系统、程序、设备或对象的结构、功能和行为，推导出其设计原理、实现细节、内部工作机制或源代码的过程。附上一些大佬对逆向工程的评价作为结束语。 Linus Torvalds（Linux 内核创始人） “如果你能通过逆向工程理解一个系统，你就有了重现或改进它的自由。这正是开源精神的延伸。” Bruce Schneier（密码学与安全专家） “逆向工程是安全研究的基石。没有它，我们无法真正理解系统的弱点，也无法构建更强的防御。” Ken Thompson（UNIX 创始人之一） “要真正理解一个程序必须能够追溯其每一行代码。逆向工程让我们看到隐藏在二进制背后的真相。” John Carmack（游戏开发者，id Software 创始人） “逆向工程不是偷窃，它是学习。当你拆解一个系统，你会发现它的美与瑕疵。” Ellen Ullman（程序员，作家） “逆向工程就像考古，挖掘代码的每一层，试图还原设计者的意图。” " }, { "title": "Hello World!", "url": "/posts/Hello-world/", "categories": "Milestone", "tags": "Hello World", "date": "2024-02-14 16:30:00 +0000", "snippet": "故事在这里开始。", "content": "故事在这里开始。" } ]
